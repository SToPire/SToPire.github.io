<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>xv6启动过程(1) | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="源码 - 从加电到进入xv6内核之前的启动过程 (1)"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2021/09/12/xv6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xv6启动过程(1)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-10 13:21:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Do not touch fish!"><span class="site-name">Do not touch fish!</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">xv6启动过程(1)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-11T17:12:48.000Z" title="发表于 2021-09-12 01:12:48">2021-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-10T05:21:33.162Z" title="更新于 2024-06-10 13:21:33">2024-06-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Code-Notes/">Code Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="xv6启动过程(1)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h4 id="加电启动bios">加电启动：BIOS</h4>
<p>现代的x86系列处理器为了保持前向兼容性，在加电启动时会工作在与8086系列处理器相同的实地址模式下。基于Intel
8086处理器的早期PC拥有1MB（20位）的地址空间，其分布如下[2]：</p>
<p>使用16位寄存器在20位地址空间中寻址需要用到两个寄存器，以CS:IP的形式表示，目标地址为CS
&lt;&lt; 4 + IP.
加电时，CS寄存器被置为0xF000，IP寄存器被置为0xFFF0（这里与8086的原始spec并非完全一致，见manual
2-29页），因此位于0xFFFF0处的BIOS代码成为被执行的第一条指令。这个位置靠近地址空间上界，所以一般是一条JMP语句，跳回BIOS区中之前的某个位置执行BIOS逻辑。BIOS与具体操作系统无关，一般与主板关联，本例中由QEMU提供，完成硬件的初始化工作。</p>
<h4 id="boot-loader接管">Boot Loader接管</h4>
<p>BIOS找到引导设备后（如硬盘），从其（这里为xv6.img）首部加载512字节的第一个扇区到物理地址0x7c00处并跳转到这里，进入bootasm.S的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code16                       # Assemble for 16-bit mode</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  cli                         # BIOS enabled interrupts; disable</span><br><span class="line"></span><br><span class="line">  # Zero data segment registers DS, ES, and SS.</span><br><span class="line">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>
<p>BIOS的工作中可能需要设置自己的中断处理程序并开中断，在加载xv6时不需要用到，所以使用<code>cli</code>关闭中断。BIOS完成工作后，3个段寄存器中的值不确定，所以将其清零。</p>
<h4 id="启动a20地址线">启动A20地址线</h4>
<p>背景[6][7]：之前提到8086的寻址方式是CS &lt;&lt; 4 +
IP，由于进位的存在，可能会加出一个21位的地址。8086会把多出来的A20地址线置零，而部分早期程序依赖了这个特性。因此为了保证前向兼容，后续型号的CPU默认禁用了A20地址线，需要手动开启。开启这一地址线的方法依赖了键盘控制器中的一个空闲位，虽然它们在功能上毫无联系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  # Physical address line A20 is tied to zero so that the first PCs </span><br><span class="line">  # with 2 MB would run software that assumed 1 MB.  Undo that.</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br></pre></td></tr></table></figure>
<p>端口0x60和0x64与键盘控制器有关，通过向端口0x60写入数据启用A20地址线；每次写入前需要在0x64处监听键盘控制器是否忙碌，直到设备空闲方可写入。</p>
<h4 id="进入protected-mode">进入protected mode</h4>
<h5 id="准备gdt">准备GDT</h5>
<p>背景[8][9]：</p>
<ol type="1">
<li><p>不同于real
mode下的寻址方式，保护模式下段寄存器不再直接存放所谓“段基址”，而是存放全局描述符表(Global
Descriptor
Table)中某条目的索引。该条目应包含某段的起始地址，此即为段基址，加上偏移量以得到物理地址。</p></li>
<li><p>x86下某GDT条目的结构如图：</p>
<figure>
<img src="/images/xv6_bootstrap_1/1.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="/images/xv6_bootstrap_1/2.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="/images/xv6_bootstrap_1/3.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>黄色部分组成了段基址，红色部分标记了段的长度，蓝色为状态标记位，意义可参见[10]。</p></li>
</ol>
<p>xv6中的GDT如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># bootstrap.S</span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULLASM                             # null seg</span><br><span class="line">  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg</span><br><span class="line">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span><br><span class="line">  </span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULLASM                                             \</span></span><br><span class="line"><span class="meta">        .word 0, 0;                                             \</span></span><br><span class="line"><span class="meta">        .byte 0, 0, 0, 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The 0xC0 means the limit is in 4096-byte units</span></span><br><span class="line"><span class="comment">// and (for executable segments) 32-bit mode.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_ASM(type,base,lim)                                  \</span></span><br><span class="line"><span class="meta">        .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span></span><br><span class="line"><span class="meta">        .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span></span><br><span class="line"><span class="meta">                (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_X     0x8       <span class="comment">// Executable segment</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_W     0x2       <span class="comment">// Writeable (non-executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_R     0x2       <span class="comment">// Readable (executable segments)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出，<code>SEG_ASM</code>宏将P位（该条目有效），S位（非系统段），G位（limit单位为页，即4KB），DB位（32位模式而非16位）均置位，将DPL（Descriptor
Privilege Level，特权级）设为0.
xv6不关注权限位这一安全机制，它们都被置0.</p>
<p>注意该宏对lim的操作抛弃了低12位而取高20位，这是因为G(ranularity)位已经将limit单位设为4KB，不需要再关心低12位的值。</p>
<p>xv6设置了空段（某些模拟器需要）[9]和code,
data段，这两个段基址均为0，limit均为4GB，这样分段其实只是走了形式。Linux也采用了这种“平坦内存模型”，依赖分页机制管理内存[8]。</p>
<h5 id="设置gdt">设置GDT</h5>
<p>x86拥有一个GDTR寄存器存储关于GDT的信息，其前2个字节为GDT的Size，后4个字节为GDT的起始地址。<code>lgdt</code>指令将指定位置的6字节数据读入GDTR寄存器。随后通过将CR0寄存器的LSB置位，进入protected
mode.对寻址方式的变更以及从16位到32位的变换不是立即发生的，而是在下一次重设段寄存器的时候进行[6]，因此<code>movl %eax, %cr0</code>的执行仍在real
mode下进行，没有问题。</p>
<figure>
<img src="/images/xv6_bootstrap_1/4.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span><br><span class="line"># virtual addresses map directly to physical addresses so that the</span><br><span class="line"># effective memory map doesn&#x27;t change during the transition.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULLASM                             # null seg</span><br><span class="line">  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg</span><br><span class="line">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span><br><span class="line">  </span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>
<p>这里的size被设为了<code>sizeof(gdt)-1</code>，可参考[11]。大意是GDT最多可为65536个字节（因为段寄存器有32位，可以索引这么多字节），但是32位寄存器存不下65536这个数，所以就将大小减1后存放。这也是GDT为什么要有一个空段的部分原因（大小不能为0）。</p>
<h5 id="重设csip">重设CS:IP</h5>
<p>通过一个<code>ljmp</code>指令重新设置段寄存器和指令寄存器，以支持保护模式下的寻址模式。<code>SEG_KCODE</code>是代码段的索引值1，左移3位是因为每个GDT条目大小为8字节，<code>CS</code>存放某条目的起始地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//PAGEBREAK!</span><br><span class="line">  # Complete the transition to 32-bit protected mode by using a long jmp</span><br><span class="line">  # to reload %cs and %eip.  The segment descriptors are set up with no</span><br><span class="line">  # translation, so that the mapping is still the identity mapping.</span><br><span class="line">  ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br></pre></td></tr></table></figure>
<h4 id="准备进入bootmain">准备进入bootmain</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.code32  # Tell assembler to generate 32-bit code now.</span><br><span class="line">start32:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  movw    $0, %ax                 # Zero segments not ready for use</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line"></span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call    bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span><br><span class="line">  # breakpoint if running under Bochs, then loop.</span><br><span class="line">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">  movw    %ax, %dx</span><br><span class="line">  outw    %ax, %dx</span><br><span class="line">  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">  outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">  jmp     spin</span><br></pre></td></tr></table></figure>
<p>此处开始生成32位汇编代码。首先设置各段寄存器的值，之后将%esp设为bootstrap汇编代码的起始位置(0x7c00)，栈会向下生长且不会与该段代码碰撞。最后调用<code>bootmain</code>，该函数不应返回，但有处理这一异常情况的代码（死循环）。</p>
<h4 id="bootmain">bootmain</h4>
<p><code>bootmain.c</code>将kernel从磁盘读入内存。</p>
<h5 id="代码逻辑">代码逻辑</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">  uchar* pa;</span><br><span class="line"></span><br><span class="line">  elf = (<span class="keyword">struct</span> elfhdr*)<span class="number">0x10000</span>;  <span class="comment">// scratch space</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read 1st page off disk</span></span><br><span class="line">  readseg((uchar*)elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is this an ELF executable?</span></span><br><span class="line">  <span class="keyword">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// let bootasm.S handle error</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load each program segment (ignores ph flags).</span></span><br><span class="line">  ph = (<span class="keyword">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class="line">  eph = ph + elf-&gt;phnum;</span><br><span class="line">  <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">    pa = (uchar*)ph-&gt;paddr;</span><br><span class="line">    readseg(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class="line">    <span class="keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class="line">      stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the entry point from the ELF header.</span></span><br><span class="line">  <span class="comment">// Does not return!</span></span><br><span class="line">  entry = (<span class="type">void</span>(*)(<span class="type">void</span>))(elf-&gt;entry);</span><br><span class="line">  entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从offset=0处读取一页（4KB）数据，判断其是否为elf文件。之后遍历program
header，将各段（以<code>off</code>为首的<code>filesz</code>长度的段）读入由<code>paddr</code>指定的物理内存地址处。如果一个段的<code>memsz</code>比<code>filesz</code>更大（比如有<code>.bss</code>节），还需要用0填充多出的部分。最后跳转到elf
header中指定的<code>entry</code>入口点：这是通过将一个函数指针指向<code>entry</code>并调用实现的，汇编层面上相当于<code>call *addr</code>，<code>addr</code>为<code>entry</code>所在的物理地址。</p>
<h5 id="elf-header-分析">ELF header 分析</h5>
<p>使用<code>readelf</code>查看kernel的segment和section如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        80100000 001000 0070da 00  AX  0   0 16</span><br><span class="line">  [ 2] .rodata           PROGBITS        801070e0 0080e0 0009cb 00   A  0   0 32</span><br><span class="line">  [ 3] .data             PROGBITS        80108000 009000 002516 00  WA  0   0 4096</span><br><span class="line">  [ 4] .bss              NOBITS          8010a520 00b516 00af88 00  WA  0   0 32</span><br><span class="line">  [ 5] .debug_line       PROGBITS        00000000 00b516 006cb5 00      0   0  1</span><br><span class="line">  [ 6] .debug_info       PROGBITS        00000000 0121cb 0121ce 00      0   0  1</span><br><span class="line">  [ 7] .debug_abbrev     PROGBITS        00000000 024399 003fd7 00      0   0  1</span><br><span class="line">  [ 8] .debug_aranges    PROGBITS        00000000 028370 0003a8 00      0   0  8</span><br><span class="line">  [ 9] .debug_str        PROGBITS        00000000 028718 000eac 01  MS  0   0  1</span><br><span class="line">  [10] .debug_loc        PROGBITS        00000000 0295c4 00681e 00      0   0  1</span><br><span class="line">  [11] .debug_ranges     PROGBITS        00000000 02fde2 000d08 00      0   0  1</span><br><span class="line">  [12] .comment          PROGBITS        00000000 030aea 00002a 01  MS  0   0  1</span><br><span class="line">  [13] .symtab           SYMTAB          00000000 030b14 002050 10     14  78  4</span><br><span class="line">  [14] .strtab           STRTAB          00000000 032b64 0011ac 00      0   0  1</span><br><span class="line">  [15] .shstrtab         STRTAB          00000000 033d10 000096 00      0   0  1</span><br><span class="line">  </span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           0x001000 0x80100000 0x00100000 0x07aab 0x07aab R E 0x1000</span><br><span class="line">  LOAD           0x009000 0x80108000 0x00108000 0x02516 0x0d4a8 RW  0x1000</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata </span><br><span class="line">   01     .data .bss </span><br><span class="line">   02     </span><br></pre></td></tr></table></figure>
<p><code>.text</code>节开始于0x1000，长度为0x70da；<code>.rodata</code>节需要对齐到32字节，故起始位置从0x80da对齐到0x80e0；<code>.data</code>节需要对齐到4096字节，故起始位置从0x8aab对齐到0x9000；<code>.bss</code>节需要对齐到32字节，故在内存中的起始位置需要从0xb516对齐到0xb520。因为<code>.bss</code>节在elf文件中不需要占据空间，它的起始位置应与随后的，应对齐到1字节的<code>.debug_line</code>节一致，故仍为0xb516。</p>
<p>00段为代码段，包括<code>.text</code>和<code>.rodata</code>节，起始位置为0x1000（与.text节一致）。它的<code>filesz</code>和<code>memsz</code>一致，均为0x7aab，与<code>.data</code>节终结于0x8aab的结论一致。</p>
<p>01段为数据段，包括<code>.data</code>和<code>.bss</code>节，起始位置为0x8000（与<code>.data</code>节一致）。它的<code>filesz</code>为0x2516，与<code>.data</code>节的size一致；它的<code>memsz</code>为0xd4a8，等于<code>.data</code>和<code>.bss</code>节的size之和（0x2516+0xaf88），再加上<code>.bss</code>为了对齐而后退的0xa个字节。</p>
<h4 id="tips">TIPS：</h4>
<ol type="1">
<li><p>可以在qemu中使用<code>Ctrl+a c</code>进入command界面，再用<code>info registers</code>查看包括GDTR在内的控制寄存器。</p></li>
<li><p>gdb的反汇编对<code>lgdt</code>的解析(<code>0F 01 16 78 7C</code>)不太正确，<code>0F 01</code>是opcode，<code>16</code>是ModR/M，<code>78 7C</code>是gdtdesc首地址。</p></li>
<li><p>为了使用vscode+gdb调试xv6，需要在启动gdb前准备好qemu并监听端口。虽然<code>launch.json</code>中有<code>preLaunchTask</code>字段，但是启动qemu的task需要监听端口而不会结束，导致调试任务等待<code>preLaunchTask</code>完成而无法继续。为了解决这个问题，可以依赖vscode自带的<code>problemMatcher</code>的tricky用法，参见<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44242048/how-to-make-vscode-not-wait-for-finishing-a-prelaunchtask">How
to make vscode not wait for finishing a preLaunchTask?</a>
另外要在<code>.gdbinit</code>里面删掉<code>target remote</code>的部分，因为连接到qemu的动作已经在<code>launch.json</code>里进行了，避免重复。</p></li>
<li><p>在<code>bootmain.c</code>中，<code>readseg</code>会委托工作给<code>readsect</code>以扇区为单位读取硬盘，如果<code>offset</code>没有对齐扇区边界，会覆盖<code>pa</code>之前的部分内容。<code>readsect</code>通过映射到端口<code>1F0</code>-<code>1F7</code>的硬盘控制器与硬盘交互，其中<code>1F0</code>为数据寄存器，<code>1F7</code>为状态寄存器（读出）/命令寄存器（写入）。</p></li>
<li><p>从<code>Makefile</code>文件中构建<code>xv6.img</code>的过程可以看出，引导块占据了0号扇区（512字节），1号扇区开始存放kernel。</p></li>
<li><p>[13]指出mmu启动前的符号因为直接使用了物理地址，而无法被gdb定位并打断点，这个现象不仅存在于linux
kernel，也存在于xv6中。文中提出的修改<code>.text</code>符号表的方式使gdb同时在物理/虚拟两个地址处设置断点，有效解决了这一问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b entry</span><br><span class="line">Breakpoint 1 at 0x8010000c: file entry.S, line 47.</span><br><span class="line">(gdb) b *0x10000c</span><br><span class="line">Breakpoint 2 at 0x10000c</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:    mov    %cr4,%eax</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 2, 0x0010000c in ?? ()</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>对<code>entry</code>打的断点落在了虚拟地址空间中，而这条语句实际是在物理地址空间<code>0x10000c</code>处被执行的，后一个断点才会命中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) add-symbol-file kernel -s .text 0x100000</span><br><span class="line">add symbol table from file &quot;kernel&quot; at</span><br><span class="line">        .text_addr = 0x100000</span><br><span class="line">(y or n) y</span><br><span class="line">Reading symbols from kernel...</span><br><span class="line">(gdb) b entry</span><br><span class="line">Breakpoint 1 at 0x10000c: entry. (2 locations)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c &lt;entry&gt;:    mov    %cr4,%eax</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, entry () at entry.S:47</span><br><span class="line">47        movl    %cr4, %eax</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x103040: main. (2 locations)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x80103040 &lt;main&gt;:   endbr32 </span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at main.c:19</span><br><span class="line">19      &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>b entry</code>
<code>b main</code>同时设置了两个断点，无论代码实际执行在虚拟地址空间（高）或物理地址空间（低）都能命中。</p></li>
</ol>
<hr />
<ol type="1">
<li>[<a target="_blank" rel="noopener" href="http://www.ufoit.com/thread-311-1-1.html">原创]BIOS
入门之一: 8086 模式 (ufoit.com)</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.cse.iitd.ac.in/~sbansal/os/previous_years/2015/lec/l10-hw3.html">Homework:
bootstrap and x86 assembly (iitd.ac.in)</a></li>
<li><a
target="_blank" rel="noopener" href="https://wjqwsp.github.io/2017/06/06/xv6-bootstrap部分源代码分析/">xv6
bootstrap部分源代码分析 | 南国倾城 (wjqwsp.github.io)</a></li>
<li><a
target="_blank" rel="noopener" href="https://people.cs.rutgers.edu/~pxk/416/notes/02-boot.html">Booting
an Operating System (rutgers.edu)</a></li>
<li><a
target="_blank" rel="noopener" href="http://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf">9800722-03_The_8086_Family_Users_Manual_Oct79.pdf
(bitsavers.org)</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.cs.columbia.edu/~junfeng/11sp-w4118/lectures/boot.pdf">boot.pdf
(columbia.edu)</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/A20_Line">A20 Line - OSDev
Wiki</a></li>
<li><a
target="_blank" rel="noopener" href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">【学习xv6】从实模式到保护模式</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/GDT_Tutorial">GDT Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Global_Descriptor_Table">Global
Descriptor Table</a></li>
<li><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67901342/why-in-xv6-theres-sizeofgdt-1-in-gdtdesc">Why
in xv6 there's sizeof(gdt)-1 in gdtdesc</a></li>
<li><a
target="_blank" rel="noopener" href="http://leenjewel.github.io/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/">【学习Xv6】加载并运行内核</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363827057">linux内存子系统 -
qemu调试linux 内核启动</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2021/09/12/xv6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-1/">https://stopire.github.io/2021/09/12/xv6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/02/xv6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-2/" title="xv6启动过程(2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">xv6启动过程(2)</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/15/XPC-Architectural-Support-for-Secure-and-Efficient-Cross-Process-Call/" title="XPC Architectural Support for Secure and Efficient Cross Process Call"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">XPC Architectural Support for Secure and Efficient Cross Process Call</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E7%94%B5%E5%90%AF%E5%8A%A8bios"><span class="toc-number">1.</span> <span class="toc-text">加电启动：BIOS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boot-loader%E6%8E%A5%E7%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">Boot Loader接管</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8a20%E5%9C%B0%E5%9D%80%E7%BA%BF"><span class="toc-number">3.</span> <span class="toc-text">启动A20地址线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5protected-mode"><span class="toc-number">4.</span> <span class="toc-text">进入protected mode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87gdt"><span class="toc-number">4.1.</span> <span class="toc-text">准备GDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEgdt"><span class="toc-number">4.2.</span> <span class="toc-text">设置GDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%AE%BEcsip"><span class="toc-number">4.3.</span> <span class="toc-text">重设CS:IP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E8%BF%9B%E5%85%A5bootmain"><span class="toc-number">5.</span> <span class="toc-text">准备进入bootmain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bootmain"><span class="toc-number">6.</span> <span class="toc-text">bootmain</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">6.1.</span> <span class="toc-text">代码逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#elf-header-%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">ELF header 分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tips"><span class="toc-number">7.</span> <span class="toc-text">TIPS：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/29/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%87%E4%BB%B6%E9%94%81%E6%8E%A5%E5%8F%A3/" title="Linux中的多种文件锁接口">Linux中的多种文件锁接口</a><time datetime="2024-05-29T10:30:30.000Z" title="发表于 2024-05-29 18:30:30">2024-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/15/Effective-Modern-C-Notes-2/" title="Effective Modern C++ Notes (2)">Effective Modern C++ Notes (2)</a><time datetime="2024-02-15T15:58:59.000Z" title="发表于 2024-02-15 23:58:59">2024-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/11/Effective-Modern-C-Notes-1/" title="Effective Modern C++ Notes (1)">Effective Modern C++ Notes (1)</a><time datetime="2024-02-10T17:48:44.000Z" title="发表于 2024-02-11 01:48:44">2024-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/26/Effective-C-Notes-2/" title="Effective C++ Notes (2)">Effective C++ Notes (2)</a><time datetime="2024-01-26T03:26:38.000Z" title="发表于 2024-01-26 11:26:38">2024-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/14/Effective-C-Notes-1/" title="Effective C++ Notes (1)">Effective C++ Notes (1)</a><time datetime="2023-12-14T07:41:28.000Z" title="发表于 2023-12-14 15:41:28">2023-12-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>