<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective Modern C++ Notes (1) | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="笔记 - 《Effective Modern C++》 (1)"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2024/02/11/Effective-Modern-C-Notes-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective Modern C++ Notes (1)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-13 10:26:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Do not touch fish!"><span class="site-name">Do not touch fish!</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Effective Modern C++ Notes (1)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-10T17:48:44.000Z" title="发表于 2024-02-11 01:48:44">2024-02-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-13T02:26:05.990Z" title="更新于 2024-06-13 10:26:05">2024-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Book-Notes/">Book Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective Modern C++ Notes (1)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="deducing-types">Deducing Types</h2>
<h3 id="item-1-understand-template-type-deduction">Item 1: Understand
template type deduction</h3>
<h4 id="模板函数类型推导">模板函数类型推导</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(expr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于以上的通用模板，其类型推导（即确定模板参数<code>T</code>的类型）同时取决于<code>ParamType</code>和<code>expr</code>的类型，遵循以下的规则：</p>
<ul>
<li><p><code>ParamType</code>是引用/指针，但不是通用引用（universal
reference），例如<code>template&lt;typename T&gt; void f(T&amp; param)</code>。</p>
<p>从字面意思看，我们想要进行引用传值，因此：</p>
<ul>
<li><code>T</code>的类型不应该包括<code>expr</code>类型中（可能）的引用/指针，因为引用/指针已经包含在<code>ParamType</code>中了。</li>
<li>如果<code>ParamType</code>没有包含cv限定符，<code>T</code>的类型应该包含<code>expr</code>类型中（可能）的cv限定符，否则<code>expr</code>的cv限定符在引用传值之后就丢失了。</li>
</ul>
<p>因此，这种情况下类型推导的行为是比较符合直觉的：</p>
<ul>
<li>如果<code>expr</code>的类型是引用，忽略引用部分。（如<code>int&amp; =&gt; int</code>）</li>
<li><code>expr</code>的类型与<code>ParamType</code>做模式匹配以确定<code>T</code>。</li>
</ul>
<blockquote>
<p>以下注释中的<code>typeof(X) == YY</code>仅表示X的类型是YY，不代表<code>typeof()</code>的实际行为，下同。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">i</span><span class="params">(T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">233</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// typeof(x) == int, typeof(T) == int, ParamType == int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// typeof(cx) == const int, typeof(T) == const int, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, typeof(T) == const int, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, 左值引用无法绑定右值，编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(x); <span class="comment">// typeof(x) == int, typeof(T) == int, ParamType == const int &amp;</span></span><br><span class="line"><span class="built_in">g</span>(cx); <span class="comment">// typeof(cx) == const int, typeof(T) == int, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">g</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, typeof(T) == int, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">g</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, typeof(T) == int, ParamType == const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">h</span>(x); <span class="comment">// typeof(x) == int, 右值引用无法绑定左值，编译失败</span></span><br><span class="line"><span class="built_in">h</span>(cx); <span class="comment">// typeof(cx) == const int, 右值引用无法绑定左值，编译失败</span></span><br><span class="line"><span class="built_in">h</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, 右值引用无法绑定左值，编译失败</span></span><br><span class="line"><span class="built_in">h</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, typeof(T) == int, ParamType == const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">i</span>(&amp;x); <span class="comment">// typeof(&amp;x) == int*, typeof(T) == int, ParamType == const int*</span></span><br><span class="line"><span class="built_in">i</span>(px); <span class="comment">// typeof(px) == const int*, typeof(T) == const int, ParamType == const int*</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>ParamType</code>是通用引用，例如<code>template&lt;typename T&gt; void f(T&amp;&amp; param)</code>。</p>
<p>通用引用希望既能绑定左值，也能绑定右值。即当<code>expr</code>的类型为左值时，<code>ParamType</code>为左值引用；当<code>expr</code>的类型为右值时，<code>ParamType</code>为右值引用。</p>
<p>为了实现这一目的，此时类型推导的行为是：</p>
<ul>
<li>如果<code>expr</code>为左值，<code>T</code>被推导为左值引用。由于引用折叠，<code>ParamType</code>的最终类型也为左值引用。</li>
<li>如果<code>expr</code>为右值，使用正常的推导规则。（即：去掉<code>expr</code>类型的引用部分，再与<code>T&amp;&amp;</code>做模式匹配。最后<code>T</code>为<code>expr</code>的原始类型，<code>ParamType</code>为右值引用）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">233</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// typeof(x) == int, typeof(T) == int&amp;, ParamType == int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// typeof(cx) == const int, typeof(T) == const int&amp;, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, typeof(T) == const int&amp;, ParamType == const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, typeof(T) == int, ParamType == int&amp;&amp;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>ParamType</code>非指针也非引用。</p>
<p>此时的语义应该是进行值传递，因此：</p>
<ul>
<li><code>param</code>不应该成为一个引用</li>
<li>如果<code>ParamType</code>不含cv限定符，<code>param</code>也不应该继承<code>expr</code>（可能）包含的cv限定符，因为它们是两个不同的变量</li>
</ul>
<p>于是此时的类型推导行为是：</p>
<ul>
<li>如果<code>expr</code>包含引用，忽略引用部分。</li>
<li>如果<code>expr</code>包含cv限定符，忽略cv限定符。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">233</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// typeof(x) == int, typeof(T) == int, ParamType == int</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// typeof(cx) == const int, typeof(T) == int, ParamType == int</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, typeof(T) == int, ParamType == int</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, typeof(T) == int, ParamType == int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(x); <span class="comment">// typeof(x) == int, typeof(T) == int, ParamType == const int</span></span><br><span class="line"><span class="built_in">g</span>(cx); <span class="comment">// typeof(cx) == const int, typeof(T) == int, ParamType == const int</span></span><br><span class="line"><span class="built_in">g</span>(rx); <span class="comment">// typeof(rx) == const int&amp;, typeof(T) == int, ParamType == const int</span></span><br><span class="line"><span class="built_in">g</span>(<span class="number">233</span>); <span class="comment">// typeof(233) == int&amp;&amp;, typeof(T) == int, ParamType == const int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> ptr = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(ptr); <span class="comment">// typeof(ptr) == const char* const, typeof(T) == const char*, ParamType == const char*</span></span><br></pre></td></tr></table></figure>
<p>注意最后<code>ptr</code>的例子：<code>param</code>只是移除了top-level
cv限定符，即指针本身的constness。指针指向的仍然是<code>const char*</code>。</p></li>
</ul>
<h4 id="数组实参">数组实参</h4>
<p>当数组实参被值传递给函数模板时，<code>T</code>和<code>ParamType</code>会退化为指针；当数组实参被引用传递给函数模板时，<code>T</code>会被推导为数组类型，形参类型则会是对数组的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(arr); <span class="comment">// typeof(arr) == int[10], typeof(T) == int*, ParamType == int*</span></span><br><span class="line"><span class="built_in">g</span>(arr); <span class="comment">// typeof(arr) == int[10], typeof(T) == int[10], ParamType == int (&amp;)[10]</span></span><br></pre></td></tr></table></figure>
<p>这一特性使我们可以通过模板参数推导获得数组大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数实参">函数实参</h4>
<p>当函数类型的实参被传递给函数模板时，若<code>ParamType</code>不是引用，<code>param</code>的类型为函数指针；若<code>ParamType</code>为引用，<code>param</code>的类型为函数的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">foo</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(foo); <span class="comment">// typeof(T) == char*(*)(int, double), ParamType == char*(*)(int, double)</span></span><br><span class="line"><span class="built_in">g</span>(foo); <span class="comment">// typeof(T) == char*(int, double), ParamType == (char*)(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<h3 id="item-2-understand-auto-type-deduction">Item 2: Understand
<code>auto</code> type deduction</h3>
<p><code>auto</code>类型推导的规则和模板类型推导基本一样，因为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = cx;</span><br></pre></td></tr></table></figure>
<p>就相当于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T &amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_rx</span>(cx);</span><br></pre></td></tr></table></figure>
<p>模板参数<code>T</code>的类型就是<code>auto</code>推导出的类型，以此类推。</p>
<p><code>auto</code>类型推导不同于模板类型推导的唯一例外来自于<code>std::initializer_list</code>，在使用花括号列表初始化<code>auto</code>变量时：</p>
<ul>
<li>如果使用了等号，<code>auto</code>被推导为<code>std::initializer_list&lt;T&gt;</code>。（如果列表中元素类型不一致，无法推导出<code>T</code>，编译失败）</li>
<li>如果不使用等号，初始化列表中只能有一个元素，并用它推导<code>auto</code>。如果初始化列表中有多个值，编译失败。</li>
</ul>
<blockquote>
<p>这是现行标准的行为，与书中描述的并不一致，见<a
target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">New
Rules for auto deduction from braced-init-list. (open-std.org)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1&#123;<span class="number">1</span>&#125;;		<span class="comment">// decltype(i1) == int</span></span><br><span class="line"><span class="type">int</span> i2 = &#123;<span class="number">2</span>&#125;;	<span class="comment">// decltype(i2) == int</span></span><br><span class="line"><span class="keyword">auto</span> i3&#123;<span class="number">3</span>&#125;;		<span class="comment">// decltype(i3) == int</span></span><br><span class="line"><span class="keyword">auto</span> i4 = &#123;<span class="number">4</span>&#125;;	<span class="comment">// decltype(i4) == std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> e = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// decltype(e) == std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> f&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; 	<span class="comment">// error: direct-list-initialization of ‘auto’ requires exactly one element</span></span><br></pre></td></tr></table></figure>
<p>而模板类型推导不会假设花括号初始化列表是<code>std::initializer_list&lt;T&gt;</code>类型，除非显式指定<code>ParamType</code>为<code>std::initializer_list&lt;T&gt;</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(std::initializer_list&lt;T&gt; param)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 编译失败，无法推断T的类型</span></span><br><span class="line"><span class="built_in">g</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// decltype(T) == int</span></span><br></pre></td></tr></table></figure>
<p>在C++14中，<code>auto</code>允许被用来推导函数返回类型，也可以在lambda函数中推导形参类型。但是在这两种场景下，<code>auto</code>都适用模板类型推导的规则。这就意味着它不会假设花括号初始化列表是<code>std::initializer_list&lt;T&gt;</code>类型。因此以下写法无法编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// error: 无法根据&#123;1, 2, 3&#125;推断返回类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bar = [](<span class="keyword">auto</span> &amp;v) &#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bar</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// error: 无法推导出&#123;1, 2, 3&#125;的类型</span></span><br></pre></td></tr></table></figure>
<h3 id="item-3-understand-decltype">Item 3: Understand decltype</h3>
<p><code>decltype</code>获得一个变量名/表达式的类型：</p>
<ol type="1">
<li>如果参数是一个变量名，<code>decltype</code>返回其完整类型（包含cv限定符和引用）</li>
<li>如果参数是一个类型为<code>T</code>的表达式，<code>decltype</code>根据表达式的值类型返回<code>T</code>或<code>T</code>的引用类型：
<ul>
<li>表达式为将亡值（xvalue），返回<code>T&amp;&amp;</code></li>
<li>表达式为左值（lvalue），返回<code>T&amp;</code></li>
<li>表达式为纯右值（prvalue），返回<code>T</code></li>
</ul></li>
</ol>
<p>这意味着<code>decltype(x)</code>和<code>decltype((x))</code>的结果可能不同，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;&amp;x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (is_same_v&lt;<span class="keyword">decltype</span>(x), <span class="type">const</span> <span class="type">int</span>&amp;&amp;&gt;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(x) is const int&amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (is_same_v&lt;<span class="keyword">decltype</span>((x)), <span class="type">const</span> <span class="type">int</span> &amp;&gt;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype((x)) is const int &amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x</code>是变量名，<code>decltype(x)</code>返回其完整类型<code>const int&amp;&amp;</code>；而<code>(x)</code>是类型为<code>const int</code>的左值表达式，因此<code>decltype((x))</code>返回其左值引用类型，即<code>const int&amp;</code>。</p>
<p><code>decltype</code>的一个典型用途是声明函数模板的返回类型，这个返回类型依赖于形参的类型，没法直接写出来。例如，由于<code>std::vector&lt;bool&gt;</code>这个特例的存在，<code>std::vector&lt;T&gt;</code>的<code>operator []</code>的返回值并不一定是<code>T&amp;</code>。</p>
<p>假设我们有一个wrapper，需要返回<code>std::vector</code>某下标处元素的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">getVector</span><span class="params">(std::vector&lt;T&gt;&amp; v, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vi = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; vb = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getVector</span>(vi, <span class="number">3</span>); <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">getVector</span>(vb, <span class="number">3</span>); <span class="comment">// 错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现，<code>getVector(vb, 3)</code>的类型并不是<code>bool&amp;</code>，而是<code>std::vector&lt;bool&gt;</code>内部的某个代理类，不能被绑定到<code>bool</code>类型的左值引用上，因此编译无法通过。</p>
<p>我们无法写出<code>getVector</code>的返回类型，因为它和<code>T</code>具体是什么有关。当然，我们可以为<code>T == bool</code>提供一个特化版本，但更优雅的解决方法是使用<code>decltype</code>推导返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getVector</span><span class="params">(std::vector&lt;T&gt;&amp; v, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(v[i])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一写法下，<code>auto</code>用来占位，真正的返回类型尾置，通过<code>decltype(v[i])</code>推导得出。当<code>T</code>不为<code>bool</code>时，这一推导会得到<code>T&amp;</code>。</p>
<p>但这一写法有个小小问题：<code>v[i]</code>在<code>return</code>语句和<code>decltype</code>中出现了两次，如果这个表达式很长，代码就会显得很啰嗦。</p>
<p>在C++14中，编译器可以根据返回语句直接推导返回类型，而不需要尾置类型，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getVector</span><span class="params">(std::vector&lt;T&gt;&amp; v, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但此时应用的是模板函数类型推导规则（而非<code>decltype</code>的推导规则），因此当<code>T</code>不为<code>bool</code>时，<code>v[i]</code>的类型为<code>T&amp;</code>，真正的返回类型为<code>T</code>。（因为返回类型<code>auto</code>并不是引用/指针类型，发生值传递）</p>
<p>这显然不是我们期望的行为，这会导致<code>getVector(vi, 3) = 4;</code>这样的语句将无法通过编译，因为赋值运算符左边是一个右值。</p>
<p>如何既不使用尾置返回类型，又使用<code>decltype</code>的推导规则呢？C++14允许我们使用<code>decltype(auto)</code>作为返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getVector</span><span class="params">(std::vector&lt;T&gt;&amp; v, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一写法表明，我们希望编译器根据返回语句推导返回类型，但使用<code>decltype</code>的推导规则，而非模板函数类型的推导规则。这一写法的效果与尾置返回类型是等价的。</p>
<h3 id="item-4-know-how-to-view-deduced-types">Item 4: Know how to view
deduced types</h3>
<p>我们可以从IDE报告的信息，编译器报错信息，或者<code>typeid(x).name</code>等方式查看类型推导的结果，但它们的保证都很弱，不一定准确，不要轻信它们。例如类型的cv限定符，引用部分等可能会丢失，见书上的例子。</p>
<blockquote>
<p>在我的实践中，通过<code>is_same_v&lt;T, U&gt;</code>(C++17之后)或<code>is_same&lt;T, U&gt;::value</code>将待测类型<code>T</code>与已知类型<code>U</code>进行比较，结果还是比较准确的。</p>
</blockquote>
<h2 id="auto"><code>auto</code></h2>
<h3 id="item-5-prefer-auto-to-explicit-type-declarations">Item 5: Prefer
<code>auto</code> to explicit type declarations</h3>
<p>作者建议能使用<code>auto</code>声明变量的地方，就尽量使用<code>auto</code>，因为：</p>
<ol type="1">
<li><p>有些类型名称非常冗长：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;           <span class="comment">//对从b到e的所有元素使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span>           <span class="comment">//dwim（“do what I mean”）算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">        <span class="comment">// typename std::iterator_traits&lt;It&gt;::value_type currValue = *b;</span></span><br><span class="line">        <span class="keyword">auto</span> currValue = *b;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>C++14中，lambda表达式的形参也可以使用<code>auto</code>，起到一定的泛型效果。在下面的例子里，如果不使用<code>auto</code>声明形参，就无法使用两个<code>double</code>变量调用<code>foo()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto foo = [](const int *a, const int *b) &#123;</span></span><br><span class="line">    <span class="keyword">auto</span> foo = [](<span class="type">const</span> <span class="keyword">auto</span> *a, <span class="type">const</span> <span class="keyword">auto</span> *b) &#123;</span><br><span class="line">        <span class="keyword">return</span> *a &lt; *b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.0</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">foo</span>(&amp;c, &amp;d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>避免发生一些隐式类型转换。例如<code>std::vector&lt;int&gt;::size()</code>的返回类型其实是<code>std::vector&lt;int&gt;::size_type</code>，如果习惯性用一个比较小的变量类型去存它，在某些平台上可能发生溢出，使用<code>auto</code>规避了这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// u_int8_t size = v.size();</span></span><br><span class="line"><span class="keyword">auto</span> size = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>另一个例子如下：<code>ump</code>中的元素类型其实是<code>std::pair&lt;const std::string, int&gt;</code>，而我们在第一轮循环中错误地遗漏了<code>const</code>。因此，编译器在每轮迭代中都会通过拷贝构造<code>ump</code>中的元素，生成一个类型为<code>std::pair&lt;std::string, int&gt;</code>的临时对象，再将<code>p</code>绑定为这个临时对象的引用。这带来了拷贝开销，并且不是我们期望的行为，我们希望<code>p</code>直接绑定为<code>ump</code>中元素的引用。使用<code>auto</code>就不会有这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; ump;</span><br><span class="line"></span><br><span class="line">    ump.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    ump.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    ump.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p: ump) &#123;</span><br><span class="line">        cout &lt;&lt; &amp;p &lt;&lt; endl; <span class="comment">// 输出临时对象的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p: ump) &#123;</span><br><span class="line">        cout &lt;&lt; &amp;p &lt;&lt; endl; <span class="comment">// 输出ump中元素的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>auto</code>能略微减少一些重构开销。如果一些变量使用<code>auto</code>声明，并使用某个函数的返回值初始化。一旦这个函数的返回类型发生改变，这些变量的类型也会一起改变。如果不使用<code>auto</code>声明，就要手动修改这些变量的类型。</p></li>
</ol>
<h3
id="item-6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types">Item
6: Use the explicitly typed initializer idiom when <code>auto</code>
deduces undesired types</h3>
<p><code>auto</code>当然也不是万能的，有时候我们需要显式指定<code>auto</code>变量的类型。</p>
<p>一个例子是<code>std::vector&lt;bool&gt;</code>带来的。在下面的代码中，我们调用<code>features()</code>生成一个<code>std::vector&lt;bool&gt;</code>类型的临时对象，并在其上调用<code>operator []</code>，用其结果初始化一个<code>auto</code>变量，然后将该变量值传递给<code>handle()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">bool</span> status)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;status: &quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">features</span>()[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">handle</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的问题是：</p>
<ul>
<li><code>std::vector&lt;bool&gt;::operator[]</code>的返回类型并不是<code>bool&amp;</code>，而是一个用于模拟<code>bool&amp;</code>行为的<code>std::vector&lt;bool&gt;::reference</code>类型。</li>
<li>这个类型可以隐式转换为<code>bool</code>，因此如果我们用<code>bool</code>来声明<code>status</code>没有任何问题。</li>
<li>然而，由于我们用<code>auto</code>声明了<code>status</code>，隐式转换并没有发生，<code>status</code>就是一个<code>std::vector&lt;bool&gt;::reference</code>类型的值，它的行为类似一个指向<code>features()</code>返回的<code>std::vector&lt;bool&gt;</code>中某个位置的引用。</li>
<li>但<code>features()</code>的返回值是一个右值，在第10行语句执行完后，这个引用(<code>status</code>)就是空悬的，因此我们将它传给<code>handle()</code>函数会导致未定义行为。</li>
</ul>
<p>要解决这个问题，我们可以不使用<code>auto</code>，或者通过一个<code>static_cast</code>显式指出我们需要的变量类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> status = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>()[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="moving-to-modern-c">Moving to Modern C++</h2>
<h3 id="item-7-distinguish-between-and-when-creating-objects">Item 7:
Distinguish between <code>()</code> and <code>&#123;&#125;</code> when creating
objects</h3>
<p>花括号初始化不允许隐式<em>narrowing conversion</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">int</span> c = &#123;a + b&#125;; <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有的话，花括号初始化总是优先匹配接收<code>std::initializer_list</code>的构造函数（即使由于<em>narrowing
conversion</em>，这样的调用无法成功）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(std::initializer_list&lt;<span class="type">int</span>&gt;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>; <span class="comment">// 调用A(int, double)</span></span><br><span class="line">    A a2&#123;<span class="number">1</span>, <span class="number">2.0</span>&#125;; <span class="comment">// 试图调用A(std::initializer_list&lt;int&gt;)，因为无法变窄转换而失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="item-8-prefer-nullptr-to-0-and-null">Item 8: Prefer
<code>nullptr</code> to <code>0</code> and <code>NULL</code></h3>
<p>C++98之前使用<code>0</code>或<code>NULL</code>表示空指针，前者的类型是<code>int</code>，后者一般也是某个整型类型。使用它们可能会被当作整形处理，丢失”空指针“的语义。</p>
<p>C++11之后最好使用<code>nullptr</code>，它的类型是<code>std::nullptr_t</code>。这个类型不是指针类型，但是可以隐式转换成任何指针类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* cp)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">takePointer</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="built_in">bar</span>(<span class="number">0</span>); 	<span class="comment">// invalid conversion: int -&gt; char*</span></span><br><span class="line">    <span class="built_in">bar</span>(<span class="literal">NULL</span>);	<span class="comment">// invalid conversion: long（或其他某种整型类型） -&gt; char*</span></span><br><span class="line">    <span class="built_in">bar</span>(<span class="literal">nullptr</span>); <span class="comment">// 正确</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">takePointer</span>(<span class="literal">nullptr</span>); <span class="comment">// 错误，nullptr不是指针类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="item-9-prefer-alias-declarations-to-typedefs">Item 9: Prefer
alias declarations to <code>typedef</code>s</h3>
<p>C++11后，声明类型别名时应该优先采用<code>using</code>，而不是C-style的<code>typedef</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::ios_base::fmtflags flags;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">using</span> flags = std::ios_base:fmtflags;</span><br></pre></td></tr></table></figure>
<p>定义一个函数指针类型时，使用<code>using</code>的语法比<code>typedef</code>容易理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FuncType = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">double</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncType)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>using</code>还可以用来声明类型别名模板（alias
template），<code>typedef</code>要想实现同样的目的，得定义一个模板类。同时，<code>using</code>还能避免出现nested
dependent type name，可以少写一个<code>typename</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">ptr_t</span> = T*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ptr</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T* type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="type">ptr_t</span>&lt;T&gt; p1; <span class="comment">// 编译器确信ptr_t&lt;T&gt;是alias template，一定是一个类型名</span></span><br><span class="line">    <span class="keyword">typename</span> ptr&lt;T&gt;::type p2; <span class="comment">// 编译器无法确定ptr&lt;T&gt;::type是类型名，万一有个偏特化把它定义成变量呢？</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="type">ptr_t</span>&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">    ptr&lt;<span class="type">int</span>&gt;::type p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="item-10-prefer-scoped-enums-to-unscoped-enums">Item 10: Prefer
scoped <code>enum</code>s to unscoped <code>enum</code>s</h3>
<p>C-style的<code>enum</code>被称为unscoped
<code>enum</code>，因为枚举名会泄漏出所在的作用域，污染全局名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; red, green, blue &#125;;</span><br><span class="line"><span class="type">int</span> red = <span class="number">1</span>; <span class="comment">// Error: Re-definition of red</span></span><br></pre></td></tr></table></figure>
<p>在C++11中，使用scoped <code>enum</code>（又称为枚举类enum
class）是更好的选择，它不污染全局名称。</p>
<p>在enum class中，枚举名是强类型，不像unscoped
<code>enum</code>的枚举名可以隐式转换为整型或浮点类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; red, green, blue &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color2</span> &#123; red, green, blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (red &gt; <span class="number">1.0</span>) &#123;&#125; <span class="comment">// 正确，隐式类型转换</span></span><br><span class="line">    <span class="keyword">if</span> (Color::red &gt; <span class="number">1.0</span>) &#123;&#125; <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enum
class的枚举名类型默认为<code>int</code>，可以显式指定这一类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; red, green, blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color2</span>: <span class="type">char</span> &#123; red, green, blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Color::red) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Color2::red) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enum class允许前置声明，unscoped
<code>enum</code>则必须指定了枚举值类型才能前置声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Color color)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color2</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color3</span> : <span class="type">int</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(Color3 color)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color3</span> : <span class="type">int</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(Color::Blue);</span><br><span class="line">    <span class="built_in">bar</span>(Color3::Blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unscoped
<code>enum</code>在少数场景下也是有用的，比如我们就是需要枚举名泄漏到自身作用域之外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"><span class="keyword">using</span> UserInfo = std::tuple&lt;std::string, std::string, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo uinfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = std::<span class="built_in">get</span>&lt;uiName&gt;(uinfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，我们将<code>std::get&lt;0&gt;(uinfo)</code>变成<code>std::get&lt;uiName&gt;(uinfo)</code>，以增加代码可读性。</p>
<p>如果要使用enum class，这个例子就不得不变成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"><span class="keyword">using</span> UserInfo = std::tuple&lt;std::string, std::string, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo uinfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name =</span><br><span class="line">        std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiName)&gt;(uinfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅需要加上枚举类的名字，还得做一次类型转换。</p>
<h3
id="item-11-prefer-deleted-functions-to-private-undefined-ones.">Item
11: Prefer deleted functions to private undefined ones.</h3>
<p>C++11之前，我们防止调用成员函数的方法是将其声明为<em>private</em>。现在可以使用<code>=delete</code>标记这些函数。</p>
<p><code>=delete</code>还可以用来删除非成员函数，比如删除函数的某些重载以防止非预期的隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span> c)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span> d)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isLucky</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">isLucky</span>(<span class="number">3.14</span>); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>=delete</code>还可以用来标记偏特化的模板函数，禁止其实例化。下面的例子里，<code>foo()</code>只接收非指针类型的实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T* t)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">foo</span>(&amp;i); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="item-12-declare-overriding-functions-override">Item 12: Declare
overriding functions <code>override</code></h3>
<p><code>override</code>用于显式指出派生类函数覆写了对应的基类函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//错误：与Base::mf1()的constness不一样，是overload而非override</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：与基类同名函数的参数列表不同，不是override</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>; <span class="comment">// 错误：与基类同名函数的引用限定符不同，不是override</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">//错误：不是虚函数，不能override</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用限定符指定成员函数只能被左值/右值对象调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>(); <span class="comment">// vals1 从左值生成</span></span><br><span class="line">    <span class="keyword">auto</span> vals2 = <span class="built_in">Widget</span>().<span class="built_in">data</span>(); <span class="comment">// vals2 从右值生成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="item-13-prefer-const_iterators-to-iterators">Item 13: Prefer
<code>const_iterator</code>s to <code>iterator</code>s</h3>
<p>对不需要修改容器元素的场景，都应该使用<code>const_iterators</code>，它是常量迭代器，不能修改所指向的元素。</p>
<p>STL容器（如<code>std::vector</code>）提供类似于<code>cbegin()</code>
<code>cend()</code> <code>crbegin()</code>
<code>crend()</code>的成员函数，用于返回<code>const_iterators</code>。</p>
<p>遍历裸数组也可以使用迭代器，C++11提供了非成员函数的<code>std::begin()</code>
和<code>std::end()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">begin</span>(arr); it != <span class="built_in">end</span>(arr); ++it) &#123;</span><br><span class="line">    *it = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是C++14才有非成员版本的<code>cbegin()</code> <code>cend()</code>
<code>rbegin()</code>
<code>crbegin()</code>等函数，如果编译器只支持到C++11，可以这么实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>container</code>是STL容器，<code>std::begin</code>将调用<code>continer.begin()</code>，返回<code>const_iterator</code>；如果<code>container</code>是裸数组，<code>std::begin</code>返回指向数组元素类型的常量指针，它们都相当于常量迭代器。</p>
<h3
id="item-14-declare-functions-noexcept-if-they-wont-emit-exceptions">Item
14: Declare functions <code>noexcept</code> if they won’t emit
exceptions</h3>
<p>C++11后，应该使用<code>noexcept</code>表示函数不抛出异常。原有的<code>throw(exception list)</code>语法已经在C++17后被移除，但是<code>throw()</code>仍可以使用，（在C++17以后）等价于<code>noexcept</code>。</p>
<p>在C++17以前，<code>noexcept</code>的性能可能比<code>throw()</code>好一点，因为：</p>
<blockquote>
<p><code>noexcept</code> is an improved version of <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/except_spec">throw()</a>,
which is deprecated in C++11. Unlike pre-C++17 <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/except_spec">throw()</a>,
<code>**noexcept**</code> will not call <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/unexpected">std::unexpected</a>,
may or may not unwind the stack, and will call <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a>,
which potentially allows the compiler to implement <code>noexcept</code>
without the runtime overhead of <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/except_spec">throw()</a>.
As of C++17, throw() is redefined to be an exact equivalent of
noexcept(true).</p>
</blockquote>
<p>标记<code>noexcept</code>可能可以提升性能：</p>
<ol type="1">
<li>编译器不需要考虑为异常处理路径生成代码。</li>
<li>库函数可能视调用的函数是否为<code>noexcept</code>，表现出不同的行为。例如，一个接收右值的<code>vector::push_back</code>不一定能用移动语义代替拷贝语义，因为如果容器发生了扩容，旧元素已经被移动走了，而在新位置移动构造新元素时抛了异常，容器的exception
safe就被破坏了。如果移动构造函数被标记为<code>noexcept</code>，<code>push_back</code>就可以放心使用移动语义。（举个例子，不代表真实实现）</li>
</ol>
<p>默认构造函数，析构函数，拷贝构造/拷贝赋值，移动构造/移动赋值，和内存释放函数（如<code>operator delete</code>）都被隐式声明成<code>noexcept</code>，除非显式通过<code>noexcept(false)</code>指定它们可能抛出异常。</p>
<h3 id="item-15-use-constexpr-whenever-possible">Item 15: Use
<code>constexpr</code> whenever possible</h3>
<p><code>constexpr</code>声明的变量是编译期常量，其值在编译期可知。因此<code>constexpr</code>变量必须被常量表达式初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cosnt <span class="type">int</span> ci = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j = i;	<span class="comment">//错误：i不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = ci;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>对象一定是<code>const</code>对象，反之不然。</p>
<p><code>constexpr</code>可以声明函数，该函数的所有实参如果都在编译期可知，并且只调用了<code>constexpr</code>函数，就可以在编译期求值；否则，该函数会在运行时进行计算，就像普通函数一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ci = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    std::array&lt;<span class="type">int</span>, f(i)&gt; a;	<span class="comment">//错误：f(i)不是const expression</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, f(ci)&gt; b;	<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下的所有计算都可以在编译期完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    : x(xVal), y(yVal)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span></span></span><br><span class="line"><span class="function">Point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,</span><br><span class="line">             (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result;</span><br><span class="line">    result.<span class="built_in">setX</span>(-p.<span class="built_in">xValue</span>()); </span><br><span class="line">    result.<span class="built_in">setY</span>(-p.<span class="built_in">yValue</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(&#123;<span class="number">3.0</span>, <span class="number">4.0</span>&#125;, &#123;<span class="number">5.0</span>, <span class="number">6.0</span>&#125;);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid = <span class="built_in">reflection</span>(mid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="item-16-make-const-member-functions-thread-safe">Item 16: Make
<code>const</code> member functions thread safe</h3>
<p>本节是想说明，在使用<code>mutable</code>实现logical
constness的成员函数时，尽管这个成员函数被标记为<code>const</code>，但却不是只读的，需要修改<code>mutable</code>成员，因此是并发不安全的。如果需要多线程调用，需要上锁或者用<code>std::atomic</code>保证并发安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// 需要修改`mutable`成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;</span><br><span class="line">			rootVals = <span class="built_in">calculateRoots</span>();</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-17-understand-special-member-function-generation">Item 17:
Understand special member function generation</h3>
<p>如果不声明任何特殊函数（默认构造，析构，拷贝构造，拷贝赋值，移动构造，移动赋值），编译器会生成它们的默认实现，但是：</p>
<ul>
<li><p>如果声明了拷贝构造函数或者拷贝赋值运算符，编译器将不会生成默认的移动构造函数/移动赋值运算符，通过右值调用构造函数/赋值运算符将会匹配到拷贝构造/拷贝赋值的版本。</p>
<blockquote>
<p>声明拷贝行为往往意味着trivial的拷贝行为不合适，此时编译器认为trivial的移动行为也不合适，因此不生成默认实现。</p>
</blockquote>
<blockquote>
<p>照理来说，声明了拷贝构造函数/拷贝赋值，意味着拷贝赋值/拷贝构造函数的trivial行为也不合适，这是Rule
of
Three的体现。但是C++98时代的编译器没有践行这个原则，还是会生成另一个拷贝操作的默认实现。</p>
<p>C++11标准认为这是不合理的，<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_constructor">写道</a>：</p>
<blockquote>
<p>The generation of the implicitly-defined copy constructor is
<strong>deprecated</strong> if <code>T</code> has a user-defined
destructor or user-defined copy assignment operator.</p>
</blockquote>
<p>但实现上，编译器往往还是会出于兼容性考虑，保持和C++98一样的行为，继续生成另一个拷贝操作的默认实现。</p>
</blockquote></li>
<li><p>如果声明了移动构造函数，拷贝构造/拷贝赋值/移动赋值都不会自动生成；如果声明了移动赋值，拷贝构造/拷贝赋值/移动构造都不会自动生成。</p>
<blockquote>
<p>如果声明了移动行为，说明拷贝的trivial行为也不合适，因此拷贝构造/拷贝赋值不会自动生成。</p>
</blockquote>
<blockquote>
<p>如果声明了移动构造/移动赋值，说明移动的trivial行为不合适，编译器也不会生成另一个移动操作（即移动赋值/移动构造）的默认实现。（这里不同于拷贝操作，因为移动操作没有历史包袱）</p>
</blockquote></li>
<li><p>如果声明了析构函数，编译器不会生成默认的移动构造函数/移动赋值运算符。</p>
<blockquote>
<p>Rule of
Three要求用户同时声明析构函数，拷贝构造和拷贝赋值，这是因为声明析构函数往往意味着类需要管理其他资源，以至于需要在析构函数中释放，这暗示了拷贝构造/拷贝赋值也不能使用默认行为。但C++98时代并没有充分重视这个推论，因此尽管声明了析构函数，编译器还是会生成默认的拷贝构造/拷贝赋值运算符；但对于移动语义就没必要前向兼容了，因此编译器不会自动生成移动构造/移动赋值运算符。</p>
</blockquote>
<blockquote>
<p>现在应该遵循的原则是Rule of
Five：同时声明析构函数，拷贝构造/赋值，移动构造/赋值。</p>
</blockquote></li>
</ul>
<h2 id="smart-pointers">Smart Pointers</h2>
<h3
id="item-18-use-stdunique_ptr-for-exclusive-ownership-resource-management">Item
18: Use <code>std::unique_ptr</code> for exclusive-ownership resource
management</h3>
<p><code>std::unique_ptr</code>的大小等同于原始指针，而且对于包括解引用在内的大多数操作，他们执行的指令完全相同。</p>
<p><code>std::unique_ptr</code>只能移动，不能拷贝。</p>
<p><code>std::unique_ptr</code>可以被指定不同的<em>deleter</em>用于替代默认的对象销毁行为，<em>deleter</em>必须是一个接受<code>unique_ptr&lt;T, Deleter&gt;::pointer</code>类型参数的<em>callable
object</em>。</p>
<p><em>deleter</em>是<code>std::unique_ptr</code>类型的一部分，因此使用不同类型的<em>deleter</em>将会影响<code>std::unique_ptr</code>对象的大小。下面的例子使用了4种不同的<em>callable
object</em>作为<em>deleter</em>，并打印出<code>std::unique_ptr</code>在我的平台下的大小：</p>
<ul>
<li>使用lambda表达式和函数对象基本不会增加<code>std::unique_ptr</code>的大小，因为此时<em>deleter</em>是一个空类，编译器可以做空基类优化（EBO），通过<em>private</em>继承的方式把<em>deleter</em>嵌入<code>std::unique_ptr</code>类型中。参考知乎用户LeeCarry的<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367412477">文章</a>。</li>
<li>使用函数指针让<code>std::unique_ptr</code>增加了一个指针大小，这是直观的结果，因为多存了一个指向<em>deleter</em>的指针。</li>
<li><code>std::function</code>太重了，直接导致<code>std::unique_ptr</code>的大小变成了40字节。</li>
</ul>
<p>因此使用lambda表达式作为<em>deleter</em>是一个兼顾易用性和内存占用的选择。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> DeleterLambda = [](A* a) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleter&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleterFunction</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleter2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleterStruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deleter3&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; DeleterFunctionObject = [](A* a) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleter4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(DeleterLambda)</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A, DeleterLambda)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(DeleterFunction)</span>*&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> A, DeleterFunction)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, DeleterStruct&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> A, DeleterStruct())</span></span>;</span><br><span class="line">    std::unique_ptr&lt;A, std::function&lt;<span class="type">void</span>(A*)&gt;&gt; <span class="built_in">p4</span>(<span class="keyword">new</span> A, DeleterFunctionObject);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p3) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p4) &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_ptr</code>还有一个用于数组的特化形式<code>std::unique_ptr&lt;T[]&gt;</code>，只有这个形式才有<code>operator []</code>。同时，只有用于非数组的一般形式才有<code>operator *</code>和<code>operator -&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    *p1;	<span class="comment">//正确</span></span><br><span class="line">    p1[<span class="number">0</span>];	<span class="comment">//错误</span></span><br><span class="line">    *p2;	<span class="comment">//错误</span></span><br><span class="line">    p2[<span class="number">0</span>];	<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，使用<code>std::array</code>等容器是比<code>std::unique_ptr&lt;T[]&gt;</code>更好的选择。</p>
<h3
id="item-19-use-stdshared_ptr-for-shared-ownership-resource-management">Item
19: Use <code>std::shared_ptr</code> for shared-ownership resource
management</h3>
<p><code>std::shared_ptr</code>确保对象在引用计数为0时被析构，相较于<code>std::unique_ptr</code>，这是要付出性能代价的：</p>
<ul>
<li><code>std::shared_ptr</code>需要包含一个指向引用计数（其实是控制块）的指针，因此大小往往是裸指针的两倍。</li>
<li>这个引用计数独立于对象存在，需要额外分配内存来存它。</li>
<li>对引用计数的修改必须是原子的，因为多个<code>std::shared_ptr</code>可能并发修改它。</li>
</ul>
<p><code>std::shared_ptr</code>也可以接收<em>deleter</em>用于自定义对象销毁行为。与<code>std::unique_ptr</code>不同的是，<code>std::shared_ptr</code>的<em>deleter</em>不是类型的一部分，而是通过构造函数传入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleter&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>), deleter)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了存储引用计数和（可能的）<em>deleter</em>等元数据，<code>std::shared_ptr</code>会维护一个指向控制块（control
block）的指针。每个被<code>std::shared_ptr</code>管理的对象都应该有且仅有一个控制块。为了确保控制块的唯一性，<code>std::shared_ptr</code>按照以下规则创建控制块：</p>
<ul>
<li><code>std::make_shared</code>总是创建控制块。</li>
<li>从<code>std::unique_ptr</code>或裸指针构建<code>std::shared_ptr</code>时，总是创建控制块。</li>
<li>从<code>std::shared_ptr</code>或<code>std::weak_ptr</code>构建<code>std::shared_ptr</code>时，不会创建控制块。</li>
</ul>
<p>因此，使用同一个裸指针初始化两个<code>std::shared_ptr</code>是一种糟糕的行为，这会导致一个对象拥有两个控制块，很可能会被析构两次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double free!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般不会写出这样的代码，因为使用裸指针接收<code>new</code>的返回值并不合适，违背了RAII原则。但是，在使用类的<code>this</code>指针时，我们可能会意外犯下这个错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        processedWidgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">    spw-&gt;<span class="built_in">process</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Widget::process()</code>中，我们使用裸指针<code>this</code>创建了一个指向<code>Widget</code>对象的<code>std::shared_ptr</code>，然而在它之前已经有一个名为<code>spw</code>的<code>std::shared_ptr</code>指向它了，因此这一用法是错误的。</p>
<p>问题的本质是我们想在成员函数中使用一个当前对象的<code>std::shared_ptr</code>。针对这一目的，标准库中提供了工具类<code>enable_shared_from_this</code>。<code>Widget</code>需要<em>public</em>继承<code>std::enable_shared_from_this&lt;Widget&gt;</code>，并使用该类中的<code>shared_from_this()</code>成员函数替代<code>this</code>指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        processedWidgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的继承方式是Effective C++ Item 49中提及的CRTP(Curiously Recurring
Template Pattern)</p>
</blockquote>
<blockquote>
<p>std::enable_shared_from_this<T>的实现细节：</p>
<ul>
<li><code>std::enable_shared_from_this&lt;T&gt;</code>包含一个<code>std::weak_ptr&lt;T&gt;</code>类型的成员变量。</li>
<li>如果<code>T</code>继承了<code>std::enable_shared_from_this&lt;T&gt;</code>，在构造<code>std::shared_ptr&lt;T&gt;</code>和<code>T</code>类型对象时，这个<code>std::weak_ptr</code>会被赋值并指向当前对象。这样一来，当前对象就可以通过这个<code>std::weak_ptr</code>拿到对应的控制块。</li>
<li>使用<code>shared_from_this()</code>时，通过这个<code>std::weak_ptr</code>初始化一个<code>std::shared_ptr</code>并返回。</li>
</ul>
<p>更多细节可以参考<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393571228">这篇文章</a>及评论。</p>
</blockquote>
<p>在C++17之前，不同于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>并没有一个<code>std::shared_ptr&lt;T[]&gt;</code>的特化版本，它也没有<code>operator[]</code>。尽管可以让<code>T</code>被推导为数组类型，并提供一个使用<code>delete []</code>的自定义<em>deleter</em>，但还是不建议用<code>std::shared_ptr</code>管理裸数组，而应该使用stl容器。</p>
<p>C++17之后，<code>std::shared_ptr</code>拥有<code>operator []</code>，也能在指向数组时默认使用<code>delete []</code>作为<em>deleter</em>，可以管理裸数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3
id="item-20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle">Item
20: Use <code>std::weak_ptr</code> for <code>std::shared_ptr</code>-like
pointers that can dangle</h3>
<p>本节介绍了<code>std::weak_ptr</code>的应用场景：</p>
<ul>
<li>Observer设计模式，一个subject对象有若干个observer对象，subject的状态改变时需要通知observer。由于subject不需要管理也不关心observer的生命周期，只是需要一个指针来通知observer，这个指针可以是<code>std::weak_ptr</code>，保证observer生命周期结束后，subject不会错误地访问它。</li>
<li>打破<code>std::shared_ptr</code>的循环引用。</li>
</ul>
<p><code>std::weak_ptr</code>虽然不影响指向对象的（强）引用计数，但它需要维护弱引用计数，因此也需要控制块。<code>std::weak_ptr</code>和<code>std::shared_ptr</code>使用相同的控制块，因此它们的性能开销也基本相同。</p>
<blockquote>
<p>Q：为什么需要弱引用计数？</p>
<p>A：弱引用计数是控制块的引用计数。对象失去最后一个弱引用计数意味着没有<code>std::weak_ptr</code>指向它了，控制块才可以被销毁。</p>
</blockquote>
<h3
id="item-21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new">Item
21: Prefer <code>std::make_unique</code> and
<code>std::make_shared</code> to direct use of <code>new</code></h3>
<p>更推荐通过<code>std::make_shared</code>和<code>std::make_unique</code>创建智能指针，而不是在智能指针的构造函数中使用<code>new</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">auto</span> p2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// recommended</span></span><br></pre></td></tr></table></figure>
<p>这样做的好处有：</p>
<ol type="1">
<li><p>不需要把类型名写两遍</p></li>
<li><p>异常安全。在<code>std::shared_ptr&lt;Widget&gt;(new Widget)</code>这种写法中，<code>new</code>和创建智能指针两个操作不是原子的，中间一旦被异常打断就会发生内存泄漏。使用<code>std::make_shared</code>不存在这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computePriority()如果抛出异常，可能导致内存泄漏</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++17后已经不存在这样的问题，见<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17">这里</a>。</p>
</blockquote></li>
<li><p><code>std::make_shared</code>会在一次内存分配中同时分配存储对象的空间，和存储<code>std::shared_ptr</code>控制块的空间，有性能优势。</p></li>
</ol>
<p>但是<em>make</em>系列函数也有局限之处：</p>
<ol type="1">
<li>不支持自定义删除器，如果有这种需求必须使用构造函数+<em>new</em>。</li>
<li>由于需要分配控制块，<code>std::make_shared</code>会分配超过对象大小的内存空间，因此它使用<code>::new</code>，而不是对象自定义的<code>operator new</code>。这一行为与构造函数+<em>new</em>不同。</li>
<li>由于<code>std::make_shared</code>分配的对象和它的控制块来自于同一次内存分配，只有当对象失去最后一个<code>std::weak_ptr</code>引用（弱引用）后（此时控制块可以被回收），这块内存才会被回收。如果对象很大，可能导致析构和内存回收之间出现较大延迟；如果使用构造函数+<em>new</em>创建指向对象的<code>std::shared_ptr</code>，控制块和对象本身位于不同内存中，因此当对象失去最后一个<code>std::shared_ptr</code>引用（强引用）后，对象内存就可以被回收。</li>
</ol>
<h3
id="item-22-when-using-the-pimpl-idiom-define-special-member-functions-in-the-implementation-file">Item
22: When using the Pimpl Idiom, define special member functions in the
implementation file</h3>
<p>我们希望用<code>std::unique_ptr</code>作为裸指针的平替实现pimpl
idiom，并写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码无法通过编译。问题在于编译器会为<code>Widget</code>生成默认析构函数（在<code>widget.h</code>中，<code>class Widget</code>的定义处），该析构函数需要析构<code>pImpl</code>变量，即使用<code>delete</code>销毁内置于<code>std::unique_ptr</code>的裸指针。但是在<code>std::unique_ptr</code>的实现中，销毁裸指针之前会通过<code>static_assert</code>确保它指向的不是一个incomplete
type，而<code>Widget::Impl</code>就是一个incomplete type，导致错误。</p>
<blockquote>
<p>使用<code>std::shared_ptr</code>代替<code>std::unique_ptr</code>则不会有这个问题，因为<code>std::shared_ptr</code>的删除器不是指针类型的一部分，允许指向一个不完整类型，而<code>std::unique_ptr</code>只能指向完整类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> up = std::<span class="built_in">unique_ptr</span>&lt;A&gt;(); <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">auto</span> sp = std::<span class="built_in">shared_ptr</span>&lt;A&gt;(); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，实现pimpl
idiom用<code>std::shared_ptr</code>太重了，因此我们不考虑用<code>std::shared_ptr</code>实现pimpl
idiom的方案。</p>
</blockquote>
<p>为了解决这个问题，我们在<code>class Widget</code>的定义中声明析构函数<code>Widget::~Widget()</code>，但在<code>Widget::Impl</code>的定义出现后才定义它（其实只是使用了默认定义）。这样一来，<code>std::unique_ptr</code>的析构函数就不会使用不完整的类型<code>Widget::Impl</code>了。</p>
<p>当然，由于我们声明了析构函数，编译器不会自动生成其他特殊函数，需要我们手动声明。它们同样要求<code>Widget::Impl</code>是完整类型，因此我们按照同样的方式处理，在<code>class Widget</code>中声明这些函数，但在<code>Widget::Impl</code>被定义后才定义。</p>
<ul>
<li>移动构造/移动赋值可以使用默认行为。</li>
<li>拷贝构造/拷贝赋值不能使用默认行为（因为<code>std::unique_ptr</code>不可拷贝），我们需要手动实现，让它们拷贝<code>pImpl</code>指针指向的<code>Widget::Impl</code>对象。</li>
</ul>
<p>因此最后的代码是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs): <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl)) &#123;&#125;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    *pImpl = *rhs.pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2024/02/11/Effective-Modern-C-Notes-1/">https://stopire.github.io/2024/02/11/Effective-Modern-C-Notes-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/15/Effective-Modern-C-Notes-2/" title="Effective Modern C++ Notes (2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Effective Modern C++ Notes (2)</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/26/Effective-C-Notes-2/" title="Effective C++ Notes (2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective C++ Notes (2)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#deducing-types"><span class="toc-number">1.</span> <span class="toc-text">Deducing Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-1-understand-template-type-deduction"><span class="toc-number">1.1.</span> <span class="toc-text">Item 1: Understand
template type deduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.1.1.</span> <span class="toc-text">模板函数类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">数组实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-2-understand-auto-type-deduction"><span class="toc-number">1.2.</span> <span class="toc-text">Item 2: Understand
auto type deduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-3-understand-decltype"><span class="toc-number">1.3.</span> <span class="toc-text">Item 3: Understand decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-4-know-how-to-view-deduced-types"><span class="toc-number">1.4.</span> <span class="toc-text">Item 4: Know how to view
deduced types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.</span> <span class="toc-text">auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-5-prefer-auto-to-explicit-type-declarations"><span class="toc-number">2.1.</span> <span class="toc-text">Item 5: Prefer
auto to explicit type declarations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><span class="toc-number">2.2.</span> <span class="toc-text">Item
6: Use the explicitly typed initializer idiom when auto
deduces undesired types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#moving-to-modern-c"><span class="toc-number">3.</span> <span class="toc-text">Moving to Modern C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-7-distinguish-between-and-when-creating-objects"><span class="toc-number">3.1.</span> <span class="toc-text">Item 7:
Distinguish between () and {} when creating
objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-8-prefer-nullptr-to-0-and-null"><span class="toc-number">3.2.</span> <span class="toc-text">Item 8: Prefer
nullptr to 0 and NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-9-prefer-alias-declarations-to-typedefs"><span class="toc-number">3.3.</span> <span class="toc-text">Item 9: Prefer
alias declarations to typedefs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-10-prefer-scoped-enums-to-unscoped-enums"><span class="toc-number">3.4.</span> <span class="toc-text">Item 10: Prefer
scoped enums to unscoped enums</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-11-prefer-deleted-functions-to-private-undefined-ones."><span class="toc-number">3.5.</span> <span class="toc-text">Item
11: Prefer deleted functions to private undefined ones.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-12-declare-overriding-functions-override"><span class="toc-number">3.6.</span> <span class="toc-text">Item 12: Declare
overriding functions override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-13-prefer-const_iterators-to-iterators"><span class="toc-number">3.7.</span> <span class="toc-text">Item 13: Prefer
const_iterators to iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-14-declare-functions-noexcept-if-they-wont-emit-exceptions"><span class="toc-number">3.8.</span> <span class="toc-text">Item
14: Declare functions noexcept if they won’t emit
exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-15-use-constexpr-whenever-possible"><span class="toc-number">3.9.</span> <span class="toc-text">Item 15: Use
constexpr whenever possible</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-16-make-const-member-functions-thread-safe"><span class="toc-number">3.10.</span> <span class="toc-text">Item 16: Make
const member functions thread safe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-17-understand-special-member-function-generation"><span class="toc-number">3.11.</span> <span class="toc-text">Item 17:
Understand special member function generation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smart-pointers"><span class="toc-number">4.</span> <span class="toc-text">Smart Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-18-use-stdunique_ptr-for-exclusive-ownership-resource-management"><span class="toc-number">4.1.</span> <span class="toc-text">Item
18: Use std::unique_ptr for exclusive-ownership resource
management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-19-use-stdshared_ptr-for-shared-ownership-resource-management"><span class="toc-number">4.2.</span> <span class="toc-text">Item
19: Use std::shared_ptr for shared-ownership resource
management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle"><span class="toc-number">4.3.</span> <span class="toc-text">Item
20: Use std::weak_ptr for std::shared_ptr-like
pointers that can dangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new"><span class="toc-number">4.4.</span> <span class="toc-text">Item
21: Prefer std::make_unique and
std::make_shared to direct use of new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-22-when-using-the-pimpl-idiom-define-special-member-functions-in-the-implementation-file"><span class="toc-number">4.5.</span> <span class="toc-text">Item
22: When using the Pimpl Idiom, define special member functions in the
implementation file</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/29/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%87%E4%BB%B6%E9%94%81%E6%8E%A5%E5%8F%A3/" title="Linux中的多种文件锁接口">Linux中的多种文件锁接口</a><time datetime="2024-05-29T10:30:30.000Z" title="发表于 2024-05-29 18:30:30">2024-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/15/Effective-Modern-C-Notes-2/" title="Effective Modern C++ Notes (2)">Effective Modern C++ Notes (2)</a><time datetime="2024-02-15T15:58:59.000Z" title="发表于 2024-02-15 23:58:59">2024-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/11/Effective-Modern-C-Notes-1/" title="Effective Modern C++ Notes (1)">Effective Modern C++ Notes (1)</a><time datetime="2024-02-10T17:48:44.000Z" title="发表于 2024-02-11 01:48:44">2024-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/26/Effective-C-Notes-2/" title="Effective C++ Notes (2)">Effective C++ Notes (2)</a><time datetime="2024-01-26T03:26:38.000Z" title="发表于 2024-01-26 11:26:38">2024-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/14/Effective-C-Notes-1/" title="Effective C++ Notes (1)">Effective C++ Notes (1)</a><time datetime="2023-12-14T07:41:28.000Z" title="发表于 2023-12-14 15:41:28">2023-12-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>