<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ Notes (2) | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="笔记 - 《Effective C++》 (2)"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2024/01/26/Effective-C-Notes-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++ Notes (2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-10 13:21:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Do not touch fish!"><span class="site-name">Do not touch fish!</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Effective C++ Notes (2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T03:26:38.000Z" title="发表于 2024-01-26 11:26:38">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-10T05:21:33.152Z" title="更新于 2024-06-10 13:21:33">2024-06-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Book-Notes/">Book Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++ Notes (2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="implementations">Implementations</h2>
<h3 id="item-26-postpone-variable-definitions-as-long-as-possible">Item
26: Postpone variable definitions as long as possible</h3>
<p>为了尽可能减少变量构造和析构成本，我们应该直到变量被使用的前一刻再定义它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    encrypted = <span class="built_in">doSomething</span>(password);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，如果我们在第4行处抛出异常，已经被构造出的<code>excrypted</code>需要被析构，尽管它从来没有被使用过。如果我们把<code>encrypted</code>的定义往后挪，就能避免这种情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string encrypted = <span class="built_in">doSomething</span>(password);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能不符合(ANSI)C语言中把变量声明全部放在函数体头部的习惯，但这是C++的best
practice。</p>
<p>对于循环变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	w = <span class="built_in">doSomething</span>(i);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	Widget w = <span class="built_in">doSomething</span>(i);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A的开销是1次构造+1次析构+n次赋值，B的开销是N次构造+n次析构，因此使用哪种需要根据具体情况下相关函数的开销而定。</p>
<h3 id="item-27-minimize-casting">Item 27: Minimize casting</h3>
<p>类型转换不仅仅是告诉编译器将一种类型视作另一种类型，还可能产生额外代码，因此是有代价的。例如整型数转浮点数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pxor    xmm0, xmm0</span><br><span class="line">cvtsi2sd        xmm0, DWORD PTR [rbp-4]</span><br><span class="line">movsd   QWORD PTR [rbp-16], xmm0</span><br></pre></td></tr></table></figure>
<p>不要试图通过将派生类对象转成基类来调用基类函数（谁会这么写？）</p>
<p>以下代码的输出是<code>0 1</code>，因为<code>Derive::foo()</code>在一个临时的<code>Base</code>对象上调用了<code>Base::foo()</code>。直接用<code>Base::foo()</code>调用就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> base_foo_called&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        base_foo_called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> derive_foo_called&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Base&gt;(*<span class="keyword">this</span>).<span class="built_in">foo</span>();</span><br><span class="line">        derive_foo_called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    d.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; d.base_foo_called &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d.derive_foo_called &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dynamic_cast</code>性能开销很大，如果有一个元素为基类指针<code>Base*</code>的容器，不要试图做这些事：</p>
<ol type="1">
<li><p>遍历每个元素，用<code>dynamic_cast</code>判断它指向的是否为派生类<code>Derived</code>，是的话调用<code>Derived::foo()</code>。</p>
<p>这样会做n次<code>dynamic_cast</code>，不如把<code>foo()</code>变成虚函数，给<code>Base::foo()</code>一个空定义，然后直接对每个元素调用<code>foo()</code>。</p></li>
<li><p>用一堆<code>if else</code>逐一判断每个元素指向对象的类型。</p>
<p>性能极差，而且每次继承体系被修改也得跟着改。应该改成基于虚函数的实现。</p></li>
</ol>
<h3 id="item-28-avoid-returning-handles-to-object-internals">Item 28:
Avoid returning "handles" to object internals</h3>
<p>如果我们有一个<code>Point</code>类和一个<code>Rectangle</code>类，<code>Rectangle</code>提供<code>upperleft()</code>成员函数，返回左上角<code>Point</code>的引用。这是一个<code>const</code>成员函数，因为该函数不修改矩形的<code>private</code>变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; x_ = x; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123; y_ = y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point &amp;<span class="title">upperleft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> upperleft_; &#125;</span><br><span class="line">    <span class="function">Point &amp;<span class="title">lowerright</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lowerright_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point upperleft_;</span><br><span class="line">    Point lowerright_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码无法通过编译，因为<code>upperleft()</code>的返回类型没有用<code>const</code>修饰，提醒我们要加上这个<code>const</code>。</p>
<p>但是，如果我们的<code>Rectangle</code>是基于pimpl实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rectangle</span>(<span class="type">const</span> Point &amp;upperleft, <span class="type">const</span> Point &amp;lowerright) &#123;</span><br><span class="line">        pImpl_ = std::<span class="built_in">make_shared</span>&lt;RectangleImpl&gt;();</span><br><span class="line">        pImpl_-&gt;upperleft_ = upperleft;</span><br><span class="line">        pImpl_-&gt;lowerright_ = lowerright;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point &amp;<span class="title">upperleft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pImpl_-&gt;upperleft_; &#125;</span><br><span class="line">    <span class="function">Point &amp;<span class="title">lowerright</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pImpl_-&gt;lowerright_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">RectangleImpl</span> &#123;</span><br><span class="line">        Point upperleft_;</span><br><span class="line">        Point lowerright_;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;RectangleImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尽管我们忘记给<code>upperleft()</code>的返回类型加<code>const</code>，这段代码仍然能通过编译，因为该函数确实没有修改<code>pImpl</code>，编译器不管嵌套类<code>RectangleImpl</code>里面的事情（对编译器来说，这是一个与<code>Rectangle</code>无关的类）。因此，可以通过如下代码修改一个<code>const</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">10</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">rec.<span class="built_in">upperleft</span>().<span class="built_in">setx</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>因此，返回一个类内部成分的handle（包括指针，引用，迭代器）是危险的，这里的内部成分是逻辑上的，不一定是对象的成员，语法上可以是对象以外的一个变量（如本例）。</p>
<p>即使我们这里给<code>Rectangle::upperleft()</code>加了<code>const</code>，虽然不能改对象了，还是有悬垂handle的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rectangle <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rectangle</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Point &amp;upperleft = <span class="built_in">foo</span>().<span class="built_in">upperleft</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; upperleft.<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; upperleft.<span class="built_in">gety</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>upperleft</code>是对<code>foo()</code>返回的临时对象内部成分的引用，因此它在第6行结束后成为一个悬垂引用，对其的访问是非法的。</p>
<p>当然，不是任何情况都不能返回指向类内部成分的handle，<code>operator[]</code>就是一个反例，它不得不这么做。</p>
<h3 id="item-29-strive-for-exception-safe-code">Item 29: Strive for
exception-safe code</h3>
<p>异常安全（exception-safe）指的是函数抛出异常后，应该仍满足：</p>
<ol type="1">
<li><p>不发生资源泄漏，例如一个拿住的锁没有释放。</p></li>
<li><p>所操作的对象仍处于一个一致（合法）的状态。</p>
<blockquote>
<p>“一致”不局限于函数完全执行，或者完全没有执行两种状态，只要是对象的一个合法状态就可以。</p>
</blockquote>
<p>一个不满足2的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBg</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> bgImage_;</span><br><span class="line">	++imageChangeCnt;</span><br><span class="line">	bgImage_ = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果创建<code>Image</code>对象时抛出异常，<code>bgImage_</code>会成为一个空悬指针。</p></li>
</ol>
<p>对于1，通过RAII资源管理类可以保证资源不泄漏（如<code>lock_guard</code>之于<code>mutex</code>）。对于2，函数的一致性保证又可以分为不同程度：</p>
<ol type="1">
<li>基本保证：异常抛出后，对象仍处于一致状态，但不知道具体是哪一种。</li>
<li>强保证：异常抛出后，对象回到函数调用之前的状态。</li>
<li>承诺不抛出异常。</li>
</ol>
<p>大部分函数很难做到3，例如一个需要分配内存的函数必须在内存不足时抛出<code>bad_alloc</code>。</p>
<p>使用copy-and-swap和pimpl
idiom是一种提供强保证的方式，即把数据成员放到impl类里，操作在impl的副本上做，最后通过不抛异常的<code>swap</code>交换新旧impl类。这样做（需要拷贝）代价很大，需要权衡。</p>
<h3 id="item-30-understand-the-ins-and-outs-of-inlining">Item 30:
Understand the ins and outs of inlining</h3>
<p><code>inline</code>向编译器发出内联申请。内联消除了函数调用开销，但也导致代码体积变大。</p>
<p>如果成员函数在类的内部定义，它被视为隐式添加了<code>inline</code>。</p>
<p>虚函数也可以被声明为<code>inline</code>，但只有当不需要动态绑定（即编译期能确定调用的是哪个版本）时才可能真正被内联。</p>
<p>派生类的构造/析构函数哪怕是空函数，也一般不会被内联。因为编译器会生成一堆代码调用父类的构造/析构函数。</p>
<p>函数模板不一定要是内联的。只有确信任何实例化出来的函数都应该被内联，才应该为函数模板添加<code>inline</code>修饰。</p>
<p>（以上为原书内容）</p>
<hr />
<p>在Modern Cpp中，<code>inline</code>的意义已经超出了它的字面意思。<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/inline">cppreference</a>指出：</p>
<blockquote>
<p>An inline function or inline variable(since C++17) has the following
properties:</p>
<ul>
<li>The definition of an inline function or variable(since C++17) must
be reachable in the translation unit where it is accessed (not
necessarily before the point of access).</li>
<li>An inline function or variable(since C++17) with <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration#external_linkage">external
linkage</a> (e.g. not declared static) has the following additional
properties:
<ul>
<li>There may be <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule">more
than one definition</a> of an inline function or variable(since C++17)
in the program as long as each definition appears in a different
translation unit and (for non-static inline functions and
variables(since C++17)) all definitions are identical. For example, an
inline function or an inline variable(since C++17) may be defined in a
header file that is included in multiple source files.</li>
<li>It must be declared inline in every translation unit.</li>
<li>It has the same address in every translation unit.</li>
</ul></li>
</ul>
</blockquote>
<p>被声明为<code>inline</code>的函数（C++17后也可以是变量）被允许在每个使用到的translation
unit中都有一份定义，非<code>inline</code>的函数和变量在整个程序中只能定义一次（one-definiton
rule）。工程上，<code>inline</code>允许我们在头文件中定义函数和变量，并被多个源代码文件包含，同时不违反one-definition
rule。这也解释了为什么类的成员函数会被隐式<code>inline</code>，因为这允许我们在头文件中定义类的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;<span class="built_in">foo</span>();&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会导致链接时的多重定义，只有给<code>foo()</code>加上<code>inline</code>才能正确链接。</p>
<h3 id="item-31-minimize-compilation-dependencies-between-files">Item
31: Minimize compilation dependencies between files</h3>
<p>编写C++程序时，如果做到将接口与类的实现分离，就可以在修改实现时避免重新编译仅依赖接口的源文件。</p>
<p>一个concrete class的例子，它没有很好地做到这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Data theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>的接口部分和实现部分在一起，同时必须<code>#include</code>与私有成员相关的头文件，引入了依赖关系。一旦这些头文件有修改，依赖了这个<code>Person</code>类的任何文件都需要一起修改。</p>
<p>为了解决这个问题，大概有两种思路：</p>
<ol type="1">
<li><p>基于pimpl idiom，此时<code>Person</code>只提供接口，称为handle
class。实现部分放到一个<code>PersonImpl</code>中去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>PersonImpl</code>的接口与<code>Person</code>完全一样，<code>Person</code>的成员函数调用<code>PersonImpl</code>的同名对应函数。</p>
<p><code>Person</code>的实现（<code>PersonImpl</code>，<code>Address</code>，<code>Data</code>）的修改不会导致依赖<code>Person</code>的代码重新编译。</p>
<p>这里我们只需要声明<code>Date</code>和<code>Address</code>，而不需要定义它们。在更复杂一点的场景中，这个<code>Date</code>的声明可能不是<code>class Date</code>，而是一个更复杂的东西（比如是一个<code>typedef BasicDate&lt;int&gt; Date</code>之类的），我们不知道要怎么声明<code>Date</code>。这种情况下，<code>Date</code>的作者应该提供一个类似<code>datefwd.h</code>的头文件，我们只要include进来就行。一个这样的例子是标准库里的<code>&lt;iosfwd&gt;</code>。</p>
<p>基于handle
class将接口与实现分离会带来一定性能损失，因为多了一个指针带来了间接访问。</p></li>
<li><p>另一个思路是将<code>Person</code>实现为interface。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">birth_date</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;Person&gt;</span></span><br><span class="line"><span class="function">    <span class="title">create</span><span class="params">(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; birth_date, <span class="type">const</span> string&amp; address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birth_date, address));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; birth_date, <span class="type">const</span> string&amp; address)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birth_date), <span class="built_in">theAddress</span>(address) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">birth_date</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theBirthDate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAddress; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string theName;</span><br><span class="line">    string theBirthDate;</span><br><span class="line">    string theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Person&gt; p = Person::<span class="built_in">create</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="string">&quot;1970-01-01&quot;</span>, <span class="string">&quot;1234 56th Street&quot;</span>);</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">birth_date</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">address</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>作为抽象基类定义了接口，<code>RealPerson</code>继承接口提供了实现。</p>
<p>基于interface将接口与实现分离会带来一定性能损失，因为所有成员函数都是虚函数，带来了查虚函数表的开销。</p></li>
</ol>
<h2 id="inheritance-and-object-oriented-design">Inheritance and
Object-oriented Design</h2>
<h3 id="item-32-make-sure-public-inheritance-models-is-a">Item 32: Make
sure public inheritance models "is-a"</h3>
<p><code>public</code>继承代表"is-a"的关系。如果<code>Derived</code>以<code>public</code>形式继承<code>Base</code>，说明<code>Derived</code>对象同时也是一个<code>Base</code>对象。</p>
<p>"is-a"意味着任何一个能对<code>Base</code>对象进行的操作也能对<code>Derived</code>对象进行，任何一个需要<code>Base</code>对象的地方也可以接受一个<code>Derived</code>对象，而不能简单依靠常识判断，例如：</p>
<ol type="1">
<li>如果<code>Bird</code>类支持<code>fly()</code>函数，那企鹅就不是鸟，因为企鹅不会飞。</li>
<li>如果<code>Rectangle</code>支持修改宽度，并且让宽度不等于长度，那<code>Square</code>就不是<code>Rectangle</code>，因为对正方形不能这么做。</li>
</ol>
<h3 id="item-33-avoid-hiding-inherited-names">Item 33: Avoid hiding
inherited names</h3>
<p>不要让派生类中的名称遮挡基类中的名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::mf1(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::mf2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::mf3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::mf3(double)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::mf1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::mf3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">mf1</span>();</span><br><span class="line">    d.<span class="built_in">mf1</span>(x); <span class="comment">// Wrong</span></span><br><span class="line">    d.<span class="built_in">mf2</span>();</span><br><span class="line">    d.<span class="built_in">mf3</span>();</span><br><span class="line">    d.<span class="built_in">mf3</span>(x); <span class="comment">// Wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Base</code>中的<code>mf1()</code>和<code>mf3()</code>两个名字被遮挡了，相当于派生类没有继承带参数版本的<code>mf1(int)</code>和<code>mf3(double)</code>。对于<code>public</code>继承而言这是不允许的。</p>
<h3
id="item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation">Item
34: Differentiate between inheritance of interface and inheritance of
implementation</h3>
<p>当派生类继承基类时，它一定继承了基类各成员函数的接口。但是否继承成员函数的实现，取决于不同成员函数的声明方式：</p>
<ul>
<li><p>纯虚函数：只继承接口，不继承实现。因为派生类必须给出纯虚函数的实现。</p>
<blockquote>
<p>语法上，纯虚函数是可以有实现的。</p>
</blockquote></li>
<li><p>普通函数（非虚函数）：继承接口和实现，并且不允许实现被修改。</p></li>
<li><p>虚函数：继承接口和默认实现。继承虚函数存在一种潜在的危险：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AirPlane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AirPlane::fly()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span> : <span class="keyword">public</span> AirPlane &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span> : <span class="keyword">public</span> AirPlane &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ModelA</code>和<code>ModelB</code>都可以使用通用的<code>fly()</code>，它们直接继承了基类实现并且未作修改。</p>
<p>但假如有一种新式飞机<code>ModelC</code>，它并不能使用<code>AirPland::fly()</code>。如果类的编写者忘记重载<code>fly()</code>，就会导致错误。我们希望发生这种情况时能报出一个编译错误。</p>
<p>一种做法是将接口继承和实现继承分离开来，把<code>AirPlane</code>的虚函数<code>fly()</code>拆成一个纯虚函数<code>fly()</code>和一个非虚函数<code>defaultFly()</code>。派生类必须重载<code>fly()</code>并显式调用<code>defaultFly()</code>来表明它们不仅希望继承接口，还希望继承实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AirPlane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defaultFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AirPlane::fly()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span> : <span class="keyword">public</span> AirPlane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">defaultFly</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span> : <span class="keyword">public</span> AirPlane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">defaultFly</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做的坏处是多引入了一个函数，不利于代码可读性。另一种方案是依赖纯虚函数的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AirPlane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AirPlane::fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;AirPlane::fly()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span> : <span class="keyword">public</span> AirPlane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; AirPlane::<span class="built_in">fly</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span> : <span class="keyword">public</span> AirPlane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; AirPlane::<span class="built_in">fly</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>效果和之前一样，派生类必须重载<code>fly()</code>。</p></li>
</ul>
<h3 id="item-35-consider-alternatives-to-virtual-function">Item 35:
Consider alternatives to virtual function</h3>
<p>以下定义一个<code>GameCharacter</code>类，并定义了一个<code>healthValue()</code>虚函数，因为不同游戏人物可能有不同的计算血量方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本章给出了实现这个需求的几种其他方式。</p>
<h4 id="non-virtual-interfacenvi">Non-Virtual Interface(NVI)</h4>
<p>该方式实现了Template
Method设计模式，<code>healthValue()</code>是一个模板方法，它不允许被派生类重载。派生类只可以重载其中的一个步骤，即<code>doHealthValue()</code>。这样一来，<code>healthValue()</code>中的一些通用步骤（日志，拿锁，验证）就可以在整个继承体系中保留。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do-something</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        <span class="comment">// do-something</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="基于函数指针">基于函数指针</h4>
<p>该方式实现了Strategy设计模式。<code>healthValue()</code>的实现不再是<code>GameCharacter</code>的一部分，而是拆分出去，通过一个函数指针被<code>GameCharacter</code>调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做的好处是：</p>
<ul>
<li>同一类型的不同对象可以拥有不同的函数指针，也就是不同的血量计算方式。</li>
<li>血量计算方式在运行时可以变更。</li>
</ul>
<p>但是，如果<code>healthFunc</code>函数需要通过<code>GameCharacter</code>的私有成员计算血量，这个做法就行不通了。</p>
<h4 id="基于stdfunction">基于<code>std::function</code></h4>
<p>和上例一样，只是把第5行定义的函数指针改为<code>std::function</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br></pre></td></tr></table></figure>
<p>这允许<code>GameCharacter</code>使用任何callable计算血量，例如函数对象，甚至其他类的成员函数（通过<code>std::bind</code>）。</p>
<h4 id="两个继承体系">两个继承体系</h4>
<p><code>HealthCalcFunc</code>形成一个自己的继承体系，<code>GameCharacter</code>包含一个指向基类<code>HealthCalcFunc</code>的指针。这是实现Strategy设计模式的经典方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SlowHealthCalcFunc</span> : <span class="keyword">public</span> HealthCalcFunc &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* hcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-36-never-redefine-an-inherited-non-virtual-function">Item
36: Never redefine an inherited non-virtual function</h3>
<p>不要重新定义继承来的非虚函数，因为非虚函数不会触发动态绑定。</p>
<h3
id="item-37-never-redefine-a-functions-inherited-default-parameter-value">Item
37: Never redefine a function's inherited default parameter value</h3>
<p>虚函数默认参数的值是静态绑定的，在编译时确定。</p>
<p>以下例子会打印出<code>x = 10</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::func with x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = <span class="number">20</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::func with x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此不要改变继承来的虚函数的默认参数的值。事实上，虚函数带有默认参数不是一个好的设计，最好通过Non-Virtual
Interface的方式写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dofunc</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的虚函数，派生类将重写这个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dofunc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::dofunc with x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重写私有的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dofunc</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::dofunc with x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3
id="item-38-model-has-a-or-is-implemented-in-terms-of-through-composition">Item
38: Model "has-a" or "is-implemented-in-terms-of" through
composition</h3>
<p>复合（composition）指一个类包含了另一个类，它可以表示一种"has-a"的关系，如<code>Person</code>之于<code>Address</code>和<code>PhoneNumber</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string theName;</span><br><span class="line">    Address address;</span><br><span class="line">    PhoneNumber number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复合还可以表示一种"is-implemented-in-terms-of"的关系，指A是利用B来实现的。这纯粹是一种实现手段，和类之间的逻辑关系无关。如下面的例子，我们基于<code>std::list</code>实现了集合<code>MySet</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-39-use-private-inheritance-judiciously">Item 39: Use
private inheritance judiciously</h3>
<p>我们知道，<code>public</code>继承代表一种"is-a"的关系，而<code>private</code>继承其实代表了一种"is-implemented-in-terms-of"的关系。如果<code>Derived</code>私有继承了<code>Base</code>，代表<code>Derive</code>只要<code>Base</code>的实现，不要<code>Base</code>的接口。这纯粹是实现细节，和类之间的逻辑关系设计无关。一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tick)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已有的<code>Timer</code>类每隔<code>tick</code>就会触发一次<code>onTick()</code>。我们的<code>Widget</code>也希望每隔一定秒数触发一次动作，因此我们<code>private</code>继承了<code>Timer</code>，并重新定义了虚函数<code>onTick()</code>。逻辑上，<code>Widget</code>类和<code>Timer</code>类没有任何关系，<code>Widget</code>并不是一个<code>Timer</code>。</p>
<p>事实上，私有继承并不是必须的，这个例子也可以通过上一节提到的复合改写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span> : <span class="keyword">public</span> Timer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样写甚至比私有继承更好，因为可以把<code>WidgetTimer</code>的定义放在其他地方，这样消除了<code>Widget</code>和<code>Timer</code>类之间的编译依赖。</p>
<p>作者给出了一个私有继承比复合更好的场景：私有继承一个没有non-static成员变量的empty
class没有空间开销，但是把这个empty class复合进来至少需要占1个字节：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget1</span>: <span class="keyword">private</span> Empty &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget2</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Widget1</code>的大小应该等于<code>int</code>的大小，<code>Widget2</code>则会比<code>int</code>更大。</p>
<h3 id="item-40-use-multiple-inheritance-judiciously">Item 40: Use
multiple inheritance judiciously</h3>
<p>使用多重继承会带来一些问题，例如：</p>
<ul>
<li><p>从多个父类继承到相同的名字会导致歧义，必须显式通过类名指定在使用哪个名字。</p></li>
<li><p>出现菱形继承时，共同父类的成员会被继承两遍。此时两个中层的派生类应该虚继承它们的共同基类。然而：</p>
<ol type="1">
<li><p>虚继承本身有性能开销。</p></li>
<li><p>虚继承出现时，虚基类的初始化由most-derived
class负责，如果most-derived
class派生了新的类，这个职责也需要转移，增加了认知成本和错误率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base constructor called with value &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1 constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived2</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MostDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MostDerived</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>(value), <span class="built_in">Derived1</span>(value), <span class="built_in">Derived2</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MostDerived constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MostDerived <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor called with value 10</span><br><span class="line">Derived1 constructor called</span><br><span class="line">Derived2 constructor called</span><br><span class="line">MostDerived constructor called</span><br></pre></td></tr></table></figure>
<p>即<code>Derived1</code>和<code>Derived2</code>对<code>Base</code>构造函数的调用都被忽略，构造函数的实际调用顺序由<code>MostDerived</code>给出。</p></li>
</ol></li>
</ul>
<p>​
作者建议少使用虚继承，用的时候最好虚继承一个没有non-static成员的基类，避免初始化带来的心智负担。</p>
<p>作者指出，一种合理的使用多重继承的场景是：一个类<code>C</code>需要<code>public</code>继承一个接口类<code>I</code>，以体现"has-a"的关系；同时，实现<code>C</code>时又需要基于一个<code>CInfo</code>类，因此<code>C</code>需要（当然不是必须，见Item
39）<code>private</code>继承<code>CInfo</code>，体现"is-implemented-in-terms-of"的关系。</p>
<h2 id="templates-and-generic-programming">Templates and Generic
Programming</h2>
<h3
id="item-41-understand-implicit-interfaces-and-compile-time-polymorphism">Item
41: Understand implicit interfaces and compile-time polymorphism</h3>
<p>类型和函数模板都是在定义程序的接口，也都提供了多态支持。</p>
<ul>
<li>类型提供了显式接口，体现在成员函数的签名上；函数模板提供了隐式接口，体现在对泛型对象执行的操作中。例如对泛型对象<code>T&amp; w</code>执行了操作<code>w.size()</code>，就意味着模板实例化时的类型<code>T</code>必须支持<code>size()</code>这一接口。</li>
<li>类型提供了运行期多态，即对虚函数的调用是在运行时动态绑定的；函数模板提供了编译期多态，通过模板实例化确定调用的函数是哪一个版本。函数重载也属于编译期多态。</li>
</ul>
<h3 id="item-42-understand-the-two-meanings-of-typename">Item 42:
Understand the two meanings of typename</h3>
<p>声明模板时可以使用<code>template &lt;typename T&gt;</code>，或者<code>template &lt;class T&gt;</code>，这两种写法完全等价。</p>
<p><code>typename</code>还有另一个用途：当我们在模板使用一个nested
dependent
name时，编译器在parse阶段无法确定这个名称究竟是一个类型名还是变量名，它默认认为这是一个变量名。我们通过在名称前加上<code>typename</code>提升编译器这其实是一个类型名。</p>
<blockquote>
<p>dependent name:
模板中一个依赖模板参数的名称，如<code>B&lt;T&gt;</code>,
<code>T::A</code>。</p>
<p>nested
name：一个位于某作用域内部（即<code>::</code>后面）的名称，如<code>std::cout</code>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* typename */</span> T::const_iterator * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，编译器在模板实例化之前无法确定<code>const_iterator</code>是一个类型名（声明一个指向迭代器的指针<code>p</code>），还是一个变量名（将该变量与变量<code>p</code>相乘），而默认的行为是后者。如果我们希望的行为是前者，就必须加上<code>typename</code>。</p>
<p>一个反例是当基类的名称是dependent name，且出现在base-class
list或者构造函数成员初始化列的时候不能加<code>typename</code>，此时名称默认被当作类型名。但该名称出现在其他地方时，仍然需要加<code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Dummy</span> &#123;</span><br><span class="line">        <span class="built_in">Dummy</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Dummy Nested;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123; <span class="comment">// 不能加typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x): Base&lt;T&gt;::<span class="built_in">Nested</span>(x) &#123; <span class="comment">// 不能加typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested tmp; <span class="comment">// 必须加typename</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了<code>typename</code>以外，<code>template</code>也被用作一个去除歧义的disambiguator。这是cppreference中的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;T&gt; s;</span><br><span class="line">    s.<span class="built_in">foo</span>&lt;T&gt;();          <span class="comment">// error: &lt; parsed as less than operator</span></span><br><span class="line">    s.<span class="keyword">template</span> <span class="built_in">foo</span>&lt;T&gt;(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>bar</code>是一个模板函数，<code>bar</code>中定义的变量<code>s</code>的类型<code>S&lt;T&gt;</code>是一个dependent
name，因此编译器（parser）无法判断<code>foo</code>这个名称的类型。它可能是一个模板，也可能是一个<code>s</code>的成员，正在与<code>T</code>进行小于比较（虽然在这个例子里不合法）。此时必须用<code>template</code>修饰<code>foo</code>消除歧义。</p>
<p><a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">cppreference</a>中介绍了dependent
name和disambiguator的更多细节。</p>
<h3
id="item-43-know-how-to-access-names-in-templatized-base-classes">Item
43: Know how to access names in templatized base classes</h3>
<p>在模板类的派生类中，编译器不会自动在（模板）基类的作用域中查找继承来的名称，如下例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::foo\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>13行对<code>foo()</code>的调用会失败，编译器不会在<code>Base&lt;T&gt;</code>中寻找<code>foo</code>函数。这么做的逻辑是模板实例化之前，不能确保<code>Base&lt;T&gt;</code>中一定还存在着<code>foo()</code>这个名称，如果有这么一个全特化模板，它没有定义<code>foo()</code>，那么<code>Derived&lt;int&gt;</code>就继承不到<code>foo()</code>这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&lt;<span class="type">int</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，需要显式告知编译器我们需要在模板基类中寻找函数名称（这一告知也同时保证该名称存在，否则会出现编译错误）。一种做法是通过<code>this-&gt;</code>调用<code>foo()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Derived : Base&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        this-&gt;foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者通过<code>using</code>告知编译器<code>foo()</code>确实存在于<code>Base&lt;T&gt;</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base&lt;T&gt;::foo;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-44-factor-parameter-independent-code-out-of-templates">Item
44: Factor parameter-independent code out of templates</h3>
<p>使用模板函数可能会导致代码膨胀。在下面的例子中，由于我们为<code>SquareMatrix</code>提供了两种实例化，<code>invert()</code>函数也会有两个实例，尽管它们唯一的区别只是维度<code>n</code>的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sm1 = <span class="built_in">SquareMatrix</span>&lt;<span class="type">double</span>, <span class="number">2</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sm2 = <span class="built_in">SquareMatrix</span>&lt;<span class="type">double</span>, <span class="number">3</span>&gt;();</span><br><span class="line"></span><br><span class="line">    sm1.<span class="built_in">invert</span>();</span><br><span class="line">    sm2.<span class="built_in">invert</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是非模板的场景，我们很可能只实现一次<code>invert()</code>，并给它一个参数<code>n</code>。对于模板场景，我们也希望这么做。我们可以令<code>SquareMatrix</code>继承一个尺寸无关的基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(<span class="type">size_t</span> n, T* pMem) : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(<span class="type">size_t</span> matrixSize)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SquareMatrixBase::invert&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">invert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n * n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里：</p>
<ul>
<li>由于矩阵数据保存在<code>SquareMatrix</code>，<code>SquareMatrixBase</code>需要维护一个指针指向矩阵数据，供矩阵操作函数（如<code>invert()</code>，这里没有体现）使用。</li>
<li><code>SquareMatrix</code>私有继承了<code>SquareMatrixBase</code>，因为这里体现的是"is-implemented-in-terms-of"的关系。</li>
<li><code>SquareMatrix</code>需要显式<code>using</code>基类中的<code>invert()</code>函数（见Item
43）。</li>
</ul>
<h3
id="item-45-use-member-function-templates-to-accept-all-compatible-types">Item
45: Use member function templates to accept "all compatible types"</h3>
<p>如果我们在实现一个智能指针类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mySmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mySmartPtr</span>() : <span class="built_in">ptr_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mySmartPtr</span><span class="params">(T* ptr)</span> : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *b;</span><br><span class="line">    Derived *d;</span><br><span class="line">    b = d;</span><br><span class="line"></span><br><span class="line">    mySmartPtr&lt;Derived&gt; spd;</span><br><span class="line">    mySmartPtr&lt;Base&gt; spb = spd; <span class="comment">// Wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望像裸指针一样，将指向派生类<code>Derived</code>的指针转换为指向基类<code>Base</code>的指针。但是<code>mySmartPtr&lt;Base&gt;</code>和<code>mySmartPtr&lt;Derived&gt;</code>是完全无关的两个类，不存在类型转换，因此第20行的赋值无法编译。</p>
<p>我们不可能穷尽智能指针所可能指向的所有类型，来写出各种构造函数，用于类型转换。因此，我们必须定义一个成员函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mySmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mySmartPtr</span>() : <span class="built_in">ptr_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mySmartPtr</span><span class="params">(T* ptr)</span> : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">mySmartPtr</span><span class="params">(<span class="type">const</span> mySmartPtr&lt;U&gt;&amp; other)</span> : ptr_(other.get()) &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;template copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，我们通过<code>ptr_(other.get())</code>将底层的裸指针互相转换，它能保证不合法的指针转换（如<code>Base*</code>到<code>Derived*</code>）无法编译，使<code>mySmartPtr</code>也表现出相同的效果。</p>
<p>值得注意的是，尽管这里定义的拷贝构造函数模板看似包括了<code>mySmartPtr</code>的默认拷贝构造函数（当<code>T</code>和<code>U</code>是同种类型时），但它并不是默认拷贝构造函数，编译器仍然会生成默认拷贝构造函数，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySmartPtr&lt;Base&gt; spb1;</span><br><span class="line">mySmartPtr&lt;Base&gt; spb2 = spb1;</span><br></pre></td></tr></table></figure>
<p>这里的构造将会匹配到默认拷贝构造函数（因为这是一个更特化的匹配），而不是这里的拷贝构造函数模板，因此不会打印出输出。</p>
<h3
id="item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired">Item
46: Define non-member functions inside templates when type conversions
are desired</h3>
<p>在Item
24中，我们通过定义一个non-member的<code>operator *</code>，允许<code>Rational</code>和<code>int</code>变量相乘。现在，我们给出一个模板化的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; n = <span class="number">0</span>, <span class="type">const</span> T&amp; d = <span class="number">1</span>) : <span class="built_in">n_</span>(n), <span class="built_in">d_</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n_; &#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> d_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n_, d_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">r1</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">r2</span><span class="params">(<span class="number">4</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    Rational&lt;<span class="type">int</span>&gt; r3 = r1 * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这段代码（19行）无法编译，因为编译器无法找到一个可供调用的<code>operator *</code>。具体来说，编译器在推导模板实参时不会考虑通过构造函数发生的隐式类型转换，因此无法将<code>int</code>转换为<code>Rational&lt;int&gt;</code>，从而推导出<code>T</code>为<code>Rational</code>。</p>
<p>我们可以在<code>Rational</code>内声明<code>operator*</code>为一个友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">friend</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，代码可以通过编译了。编译器完成<code>operator*</code>调用的逻辑是：</p>
<ol type="1">
<li>定义<code>r1</code>时，<code>Rational&lt;int&gt;</code>这个类就已经被实例化了，其中<code>T</code>为<code>int</code>。</li>
<li><code>Rational&lt;int&gt;</code>中声明了一个含有两个<code>Rational&lt;int&gt;</code>形参的函数<code>operator*</code>，这个函数没有用<code>template</code>修饰，不是模板函数。</li>
<li>调用非模板函数时，编译器会考虑隐式类型转换，并且<code>int</code>确实可以隐式转换成<code>Rational&lt;int&gt;</code>，调用成功。</li>
</ol>
<p>然而，这段代码现在无法链接，因为<code>operator*</code>只有声明没有定义。</p>
<blockquote>
<p>Q:11-14行不是定义了<code>operator*</code>吗？</p>
<p>A:那只是一个从来没有被实例化过的函数模板罢了，我们现在需要的<code>operator*</code>是一个非模板函数，它们根本就不是同一个函数。</p>
</blockquote>
<p>我们可以通过以下方式修正这个程序：</p>
<ol type="1">
<li><p>定义一个<code>Rational&lt;int&gt;</code>版本的<code>operator*</code>，这显然不是一个通用的方案，丧失了模板的优势。这里只是用来证明为<code>operator*</code>提供一个（当前实例化下的）定义确实可以成功链接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;<span class="type">int</span>&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> Rational&lt;<span class="type">int</span>&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;<span class="type">int</span>&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接在声明友元函数时给出定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">friend</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这显然是一个更好的方案。把友元函数在类的内部定义产生的副作用是它会被隐式<code>inline</code>，如果我们担心<code>operator*</code>的函数体过长而不适合<code>inline</code>，可以把实现部分定义在类的外面，友元函数只是调用实现函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; n = <span class="number">0</span>, <span class="type">const</span> T&amp; d = <span class="number">1</span>) : <span class="built_in">n_</span>(n), <span class="built_in">d_</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n_; &#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> d_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">do_multiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n_, d_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Rational&lt;T&gt; <span class="title">do_multiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    Rational&lt;T&gt; ret;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="item-47-use-traits-classes-for-information-about-types">Item 47:
Use traits classes for information about types</h3>
<p>C++
中的trait类是一种用于提取类型信息或执行编译时判定的机制。一个例子是<code>iterator_traits</code>类，它使用户可以在运行时确定迭代器的类型、<code>value_type</code>等信息。</p>
<p>以迭代器类型（<code>input</code> <code>output</code>
<code>forward</code> <code>bidirectional</code>
<code>random_access</code>）为例，<code>iterator_traits</code>的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(std::input_iterator_tag, IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(std::random_access_iterator_tag, IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random_access_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(std::bidirectional_iterator_tag, IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bidirectional_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myAdvance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;    </span><br><span class="line">    <span class="built_in">doAdvance</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>(), iter, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>myAdvance</code>需要移动迭代器，但是不同类型迭代器支持的操作不同，<code>myAdvance</code>的实现也应该不同。于是，<code>myAdvance</code>通过<code>iterator_traits</code>在编译期获得迭代器的类型，并根据该类型，通过函数重载（编译期确定）调用对应版本的<code>doAdvance</code>函数。</p>
<p><code>iterator_traits</code>的实现类似于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_iterator_traits</span>&lt;IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代器的实现者需要在类型定义时<code>typedef</code>出<code>iterator_category</code>这个类型名，<code>iterator_traits</code>会直接使用这个类型。由于指针也是一种迭代器，而基本类型里没有办法<code>typedef</code>，<code>iterator_traits</code>还有一个偏特化的版本用于处理指针，并将指针标为随机访问迭代器。</p>
<p>另一个通过偏特化实现的traits例子是<code>is_same</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_is_same</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_is_same</span>&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-48-be-aware-of-template-metaprogramming">Item 48: Be aware
of template metaprogramming</h3>
<p>本节介绍了模板元编程的基本概念，给出了一个计算阶乘的Hello-world示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> value = n * Factorial&lt;n - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; endl; <span class="comment">// 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="customizing-new-and-delete">Customizing new and delete</h2>
<h3 id="item-49-understand-the-behavior-of-the-new-handler">Item 49:
Understand the behavior of the new-handler</h3>
<p><code>operator new</code>有一个<code>nothrow</code>版本，签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( std::<span class="type">size_t</span> count, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; tag )</span></span>;</span><br></pre></td></tr></table></figure>
<p>用户通过以下方式调用<code>nothrow</code>版本的<code>new</code>，它不会抛出<code>bad_alloc</code>异常，而是在分配失败时返回空指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>但是，对于非基本类型，<code>new</code>和构造函数往往是一起被调用的，就算分配失败时<code>new</code>不抛异常，构造函数也很可能抛异常。所以不要因为用了<code>nothrow</code>版本的<code>new</code>就忽略异常处理。</p>
<p>当<code>operator new</code>无法满足内存分配请求时，它会调用一个<code>new_handler</code>函数，然后再次尝试分配，重复此过程直到分配成功或抛出异常为止。</p>
<p><code>&lt;new&gt;</code>头文件中定义了<code>new_handler</code>相关的基础设施：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** If you write your own error handler to be called by @c new, it must</span></span><br><span class="line"><span class="comment">   *  be of this type.  */</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Takes a replacement handler as the argument, returns the</span></span><br><span class="line">  <span class="comment">/// previous handler.</span></span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="comment">/// Return the current new handler.</span></span><br><span class="line">  <span class="function">new_handler <span class="title">get_new_handler</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>set_new_handler</code>设置一个自定义的<code>new_handler</code>并返回旧的那个，<code>get_new_handler</code>返回当前的<code>new_handler</code>。</p>
<p>如果我们希望在分配不同类型的对象时，使用不同的<code>new_handler</code>处理失败，可以采取以下的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    new_handler handler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> </span>&#123;</span><br><span class="line">        new_handler oldHandler = currentHandler;</span><br><span class="line">        currentHandler = p;</span><br><span class="line">        <span class="keyword">return</span> oldHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里<code>NewHandlerHolder</code>是一个RAII类，它管理的资源是global版本的<code>new_handler</code>。</p>
<p>用户通过<code>Widget::set_handler</code>指定专供<code>new Widget</code>使用的<code>new_handler</code>，这个局部<code>new_handler</code>会在<code>Widget::new</code>每次被调用时被设置，并在调用结束后恢复成全局<code>new_handler</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">    Widget* pw1 = <span class="keyword">new</span> Widget; <span class="comment">// calls outOfMem if memory request fails</span></span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::string; <span class="comment">// uses std::set_new_handler</span></span><br><span class="line">    Widget* pw2 = <span class="keyword">new</span> Widget; <span class="comment">// calls outOfMem if memory request fails</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，这种为不同类型提供自定义<code>new_handler</code>的方式是通用的，对<code>Widget</code>是这样，对其他类也是这样。因此，我们可以通过模板复用这个方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    new_handler handler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>NewHandlerHolder</code>的基础上，我们定义了一个模板类<code>NewHandlerSupport</code>，它定义了自己的<code>set_new_handler</code>和<code>new</code>，从而使我们不需要像之前那样侵入式地修改<code>Widget</code>类。现在，<code>Widget</code>只需要<code>public</code>继承<code>NewHandlerSupport&lt;Widget&gt;</code>获得这两个接口即可。</p>
<p>注意这里<code>NewHandlerSupport</code>虽然是模板类，但内部实现完全与模板参数<code>T</code>无关。这里<code>T</code>的唯一作用就是让<code>NewHandlerSupport</code>的不同派生类拥有各自的基类，即<code>NewHandlerSupport&lt;T&gt;</code>。这也是为什么<code>Widget</code>要继承<code>NewHandlerSupport&lt;Widget&gt;</code>，把自己的类名当作模板参数<code>T</code>。这种继承方式被称为CRTP(Curiously
Recurring Template Pattern)。</p>
<h3
id="item-50-understand-when-it-makes-sense-to-replace-new-and-delete">Item
50: Understand when it makes sense to replace new and delete</h3>
<p>本节泛泛而谈了一些需要自定义<code>new</code>和<code>delete</code>的理由：</p>
<ul>
<li>针对应用的内存分配pattern和使用场景，实现特化的分配器以提升分配性能，或者降低内存分配器的内存占用。</li>
<li>收集内存使用的统计信息。</li>
<li>检测内存分配错误，例如<code>new</code>的时候写入canary值，<code>delete</code>时检查。</li>
<li>实现一些非传统行为，例如用<code>new</code>和<code>delete</code>封装C语言共享内存API。</li>
<li>实现自定义的内存对齐需求。C++17已经提供了接受alignment版本的<code>new</code>和<code>delete</code>。</li>
</ul>
<h3 id="item-51-adhere-to-convention-when-writing-new-and-delete">Item
51: Adhere to convention when writing new and delete</h3>
<p>实现自定义版本的<code>new</code>和<code>delete</code>时，应该让它们表现出与默认版本类似的行为，例如：</p>
<ul>
<li>每当分配失败时，调用<code>new_handler</code>（如果存在）并重试，直到分配成功为止。</li>
<li>将申请分配0字节的请求视为分配1字节，因为C++标准通常规定分配器应该返回一个指向足够大的内存块的指针，使得在这个内存块上进行存储是安全的。</li>
</ul>
<p>一个典型的<code>operator new</code>的逻辑类似于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new_handler globalHandler = <span class="built_in">get_new_handler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (globalHandler) &#123;</span><br><span class="line">            (*globalHandler)();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时，我们提供给基类的<code>new</code>就是为基类设计的，不想给派生类使用，此时可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived *d = <span class="keyword">new</span> Derived; <span class="comment">// custom new</span></span><br><span class="line">    Base *b = <span class="keyword">new</span> Base; <span class="comment">// ::operator new</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将<code>size</code>和<code>sizeof(Base)</code>比较，得知分配的是否为基类对象。</p>
<p>对于<code>delete</code>，我们应该保证<code>delete</code>一个空指针是安全的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像上面的例子一样，我们为基类和派生类调用了不同版本的<code>new</code>函数，<code>delete</code>也要相应处理这种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base)) &#123;</span><br><span class="line">            ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="item-52-write-placement-delete-if-you-write-placement-new">Item
52: Write placement delete if you write placement new</h3>
<p>如下所示，我们定义了一个<code>Widget</code>类并提供了自定义的<code>new()</code>，它除了<code>size_t</code>外还接受一个<code>string</code>作为参数。如果我们不想让局部定义的名称<code>new</code>遮挡住标准库里的<code>::new</code>的话，就应该同时定义<code>new(size_t size)</code>这个重载，它调用<code>:: operator new</code>。<code>delete()</code>同理。</p>
<blockquote>
<p>事实上，标准库里的<code>operator new</code>有多个重载版本，这里只考虑了<code>new(size_t size)</code>这一个版本。我们可以考虑声明一个<code>StandardNewDeleteForms</code>类，把标准库里所有的<code>new</code>和<code>delete</code>都包装一层，然后让<code>Widget</code>
<code>public</code>继承<code>StandardNewDeleteForms</code>并<code>using</code>
<code>operator new</code>和<code>operator delete</code>这两个名称，这样就不会有遮挡全局名称的问题了。</p>
</blockquote>
<p>现在的问题是：<code>Widget *pw1 = new Widget</code>意味着调用了两个函数：<code>new()</code>和<code>Widget</code>的构造函数。如果<code>new()</code>成功了但是构造函数抛出异常，编译器生成的代码需要保证<code>delete()</code>被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Widget::operator new &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Widget::operator delete &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Widget</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;rtErr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Widget *pw1 = <span class="built_in">new</span> (<span class="string">&quot;HaHa&quot;</span>) Widget;</span><br><span class="line">        <span class="keyword">delete</span> pw1;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，编译器怎么知道需要被“撤销”的那个<code>new()</code>对应的<code>delete()</code>函数是哪个呢？答案是，它会寻找<strong>额外</strong>参数个数和类型都与<code>new()</code>完全相同的那个<code>delete()</code>，并使用与调用<code>new()</code>时相同的额外参数调用它。如果找不到，它就不会调用<code>delete()</code>造成，内存泄漏。</p>
<p>额外参数指的是除了<code>size_t</code>（对于<code>new()</code>）或者<code>void *</code>（对于<code>delete()</code>）以外的其他参数，拥有额外参数的<code>new()</code>被称为placement
new，拥有额外参数的<code>delete()</code>被称为placement delete。</p>
<blockquote>
<p>当额外参数是一个<code>void *</code>时，这个<code>new()</code>是一个狭义上的placement
new，用于在一个指定的内存位置上创建对象。</p>
</blockquote>
<p>因此，当我们自定义了一个placement
new时，不能忘记同时定义对应的placement
delete，否则就有内存泄漏的风险。</p>
<p>需要注意的是，29行的<code>delete pw1</code>如果被执行，调用的仍然是non-placement版本的<code>delete</code>（因为我们没有提供<code>string</code>参数）。上述的placement
new/delete对应规则仅在构造函数抛出异常时触发。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2024/01/26/Effective-C-Notes-2/">https://stopire.github.io/2024/01/26/Effective-C-Notes-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/11/Effective-Modern-C-Notes-1/" title="Effective Modern C++ Notes (1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Effective Modern C++ Notes (1)</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/14/Effective-C-Notes-1/" title="Effective C++ Notes (1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective C++ Notes (1)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#implementations"><span class="toc-number">1.</span> <span class="toc-text">Implementations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-26-postpone-variable-definitions-as-long-as-possible"><span class="toc-number">1.1.</span> <span class="toc-text">Item
26: Postpone variable definitions as long as possible</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-27-minimize-casting"><span class="toc-number">1.2.</span> <span class="toc-text">Item 27: Minimize casting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-28-avoid-returning-handles-to-object-internals"><span class="toc-number">1.3.</span> <span class="toc-text">Item 28:
Avoid returning &quot;handles&quot; to object internals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-29-strive-for-exception-safe-code"><span class="toc-number">1.4.</span> <span class="toc-text">Item 29: Strive for
exception-safe code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-30-understand-the-ins-and-outs-of-inlining"><span class="toc-number">1.5.</span> <span class="toc-text">Item 30:
Understand the ins and outs of inlining</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-31-minimize-compilation-dependencies-between-files"><span class="toc-number">1.6.</span> <span class="toc-text">Item
31: Minimize compilation dependencies between files</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheritance-and-object-oriented-design"><span class="toc-number">2.</span> <span class="toc-text">Inheritance and
Object-oriented Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-32-make-sure-public-inheritance-models-is-a"><span class="toc-number">2.1.</span> <span class="toc-text">Item 32: Make
sure public inheritance models &quot;is-a&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-33-avoid-hiding-inherited-names"><span class="toc-number">2.2.</span> <span class="toc-text">Item 33: Avoid hiding
inherited names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><span class="toc-number">2.3.</span> <span class="toc-text">Item
34: Differentiate between inheritance of interface and inheritance of
implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-35-consider-alternatives-to-virtual-function"><span class="toc-number">2.4.</span> <span class="toc-text">Item 35:
Consider alternatives to virtual function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#non-virtual-interfacenvi"><span class="toc-number">2.4.1.</span> <span class="toc-text">Non-Virtual Interface(NVI)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.4.2.</span> <span class="toc-text">基于函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Estdfunction"><span class="toc-number">2.4.3.</span> <span class="toc-text">基于std::function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">2.4.4.</span> <span class="toc-text">两个继承体系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-36-never-redefine-an-inherited-non-virtual-function"><span class="toc-number">2.5.</span> <span class="toc-text">Item
36: Never redefine an inherited non-virtual function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-37-never-redefine-a-functions-inherited-default-parameter-value"><span class="toc-number">2.6.</span> <span class="toc-text">Item
37: Never redefine a function&#39;s inherited default parameter value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-38-model-has-a-or-is-implemented-in-terms-of-through-composition"><span class="toc-number">2.7.</span> <span class="toc-text">Item
38: Model &quot;has-a&quot; or &quot;is-implemented-in-terms-of&quot; through
composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-39-use-private-inheritance-judiciously"><span class="toc-number">2.8.</span> <span class="toc-text">Item 39: Use
private inheritance judiciously</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-40-use-multiple-inheritance-judiciously"><span class="toc-number">2.9.</span> <span class="toc-text">Item 40: Use
multiple inheritance judiciously</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#templates-and-generic-programming"><span class="toc-number">3.</span> <span class="toc-text">Templates and Generic
Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-41-understand-implicit-interfaces-and-compile-time-polymorphism"><span class="toc-number">3.1.</span> <span class="toc-text">Item
41: Understand implicit interfaces and compile-time polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-42-understand-the-two-meanings-of-typename"><span class="toc-number">3.2.</span> <span class="toc-text">Item 42:
Understand the two meanings of typename</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-43-know-how-to-access-names-in-templatized-base-classes"><span class="toc-number">3.3.</span> <span class="toc-text">Item
43: Know how to access names in templatized base classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-44-factor-parameter-independent-code-out-of-templates"><span class="toc-number">3.4.</span> <span class="toc-text">Item
44: Factor parameter-independent code out of templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-45-use-member-function-templates-to-accept-all-compatible-types"><span class="toc-number">3.5.</span> <span class="toc-text">Item
45: Use member function templates to accept &quot;all compatible types&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired"><span class="toc-number">3.6.</span> <span class="toc-text">Item
46: Define non-member functions inside templates when type conversions
are desired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-47-use-traits-classes-for-information-about-types"><span class="toc-number">3.7.</span> <span class="toc-text">Item 47:
Use traits classes for information about types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-48-be-aware-of-template-metaprogramming"><span class="toc-number">3.8.</span> <span class="toc-text">Item 48: Be aware
of template metaprogramming</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#customizing-new-and-delete"><span class="toc-number">4.</span> <span class="toc-text">Customizing new and delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item-49-understand-the-behavior-of-the-new-handler"><span class="toc-number">4.1.</span> <span class="toc-text">Item 49:
Understand the behavior of the new-handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-50-understand-when-it-makes-sense-to-replace-new-and-delete"><span class="toc-number">4.2.</span> <span class="toc-text">Item
50: Understand when it makes sense to replace new and delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-51-adhere-to-convention-when-writing-new-and-delete"><span class="toc-number">4.3.</span> <span class="toc-text">Item
51: Adhere to convention when writing new and delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-52-write-placement-delete-if-you-write-placement-new"><span class="toc-number">4.4.</span> <span class="toc-text">Item
52: Write placement delete if you write placement new</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/29/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%87%E4%BB%B6%E9%94%81%E6%8E%A5%E5%8F%A3/" title="Linux中的多种文件锁接口">Linux中的多种文件锁接口</a><time datetime="2024-05-29T10:30:30.000Z" title="发表于 2024-05-29 18:30:30">2024-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/15/Effective-Modern-C-Notes-2/" title="Effective Modern C++ Notes (2)">Effective Modern C++ Notes (2)</a><time datetime="2024-02-15T15:58:59.000Z" title="发表于 2024-02-15 23:58:59">2024-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/11/Effective-Modern-C-Notes-1/" title="Effective Modern C++ Notes (1)">Effective Modern C++ Notes (1)</a><time datetime="2024-02-10T17:48:44.000Z" title="发表于 2024-02-11 01:48:44">2024-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/26/Effective-C-Notes-2/" title="Effective C++ Notes (2)">Effective C++ Notes (2)</a><time datetime="2024-01-26T03:26:38.000Z" title="发表于 2024-01-26 11:26:38">2024-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/14/Effective-C-Notes-1/" title="Effective C++ Notes (1)">Effective C++ Notes (1)</a><time datetime="2023-12-14T07:41:28.000Z" title="发表于 2023-12-14 15:41:28">2023-12-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>