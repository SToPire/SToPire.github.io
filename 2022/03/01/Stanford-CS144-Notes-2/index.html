<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Stanford CS144 Notes(2) | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Stanford Introduction to Computer Networking CS144 class notes, Chapter 5 - Chapter 8.(videos)  Chapter 5 Applications and NATs 5-1 ~ 5-4 Network Addr"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2022/03/01/Stanford-CS144-Notes-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Stanford CS144 Notes(2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-16 15:26:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/post-cover/cover4.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Do not touch fish!"><span class="site-name">Do not touch fish!</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Stanford CS144 Notes(2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-01T11:17:37.000Z" title="发表于 2022-03-01 19:17:37">2022-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-16T07:26:12.467Z" title="更新于 2022-11-16 15:26:12">2022-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Stanford CS144 Notes(2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Stanford Introduction to Computer Networking <a
target="_blank" rel="noopener" href="https://cs144.github.io/">CS144</a> class notes, Chapter 5 -
Chapter 8.<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV137411Z7LR">(videos)</a></p>
<span id="more"></span>
<h3 id="chapter-5-applications-and-nats">Chapter 5 Applications and
NATs</h3>
<h4 id="network-address-translation">5-1 ~ 5-4 Network Address
Translation</h4>
<p>NAT使其后的设备可以以同一个公网IP和外界通信，原理是替换报文中的IP地址和端口号：</p>
<ul>
<li>对内部发往外部的包，替换源IP和源端口号为NAT的external
IP和端口号，并记录映射关系。</li>
<li>对外部发往内部的包，根据映射关系，替换目的IP和目的端口号为内部设备的IP和端口号。</li>
</ul>
<p>NAT根据翻译方式的不同可以分为以下几类：</p>
<ol type="1">
<li><p>Full-cone，对任何外部发来的包，只要目的IP和端口号匹配某条映射关系，就将其转发往对应的内部设备。</p>
<ul>
<li>Once an internal address (iAddr:iPort) is mapped to an external
address (eAddr:ePort), any packets from iAddr:iPort are sent through
eAddr:ePort.</li>
<li>Any external host can send packets to iAddr:iPort by sending packets
to eAddr:ePort.</li>
</ul></li>
<li><p>(Address)-restricted-cone，对外部发来的包，如目的IP和端口号匹配某条映射关系，且该内部（IP，端口号）曾向该源IP发送过包，才将其转发往对应的内部设备。</p>
<ul>
<li><p>Once an internal address (iAddr:iPort) is mapped to an external
address (eAddr:ePort), any packets from iAddr:iPort are sent through
eAddr:ePort.</p></li>
<li><p>An external host (<em>hAddr:any</em>) can send packets to
iAddr:iPort by sending packets to eAddr:ePort only if iAddr:iPort has
previously sent a packet to hAddr:<em>any</em>. "Any" means the port
number doesn't matter.</p></li>
</ul></li>
<li><p>Port-restricted-cone，在2的基础上，还要求内部（IP，端口号）曾向该源（IP，端口号）发送过包，才进行转发。</p>
<ul>
<li>Once an internal address (iAddr:iPort) is mapped to an external
address (eAddr:ePort), any packets from iAddr:iPort are sent through
eAddr:ePort.</li>
<li>An external host (<em>hAddr:hPort</em>) can send packets to
iAddr:iPort by sending packets to eAddr:ePort only if iAddr:iPort has
previously sent a packet to hAddr:hPort.</li>
</ul></li>
<li><p>Symmetric，同一内部IP和端口向外部每个（IP，端口号）发起的连接都是一个独立的映射，只有收到包的外部主机才能对该源（IP，端口号）发起回复。</p>
<ul>
<li>The combination of one internal IP address plus a destination IP
address and port is mapped to a single unique external source IP address
and port; if the same internal host sends a packet even with the same
source address and port but to a different destination, a different
mapping is used.</li>
<li>Only an external host that receives a packet from an internal host
can send a packet back.</li>
</ul></li>
</ol>
<p><img src="/images/CS144/5.png" /></p>
<h5 id="nat-hairpinningnat-loopback">NAT hairpinning/NAT loopback</h5>
<p>这是NAT需要考虑的一种特殊情况，支持该特性的NAT允许局域网内的设备使用另一设备的公网IP和端口号访问它。</p>
<p>如果设备A使用内网设备B在NAT那里的公网IP和端口号发起请求，按照通常的情形，NAT只对请求报文里的目的IP和端口号做替换，源IP和端口号不变；B回复的时候使用A的IP和端口号作为目的IP和端口号，NAT再把回复报文里的源IP和端口号换成B在NAT上的公网IP和端口号。但如果A和B位于同一内网中：</p>
<ol type="1">
<li>A请求B：<span class="math inline">\((IP_{Ain},P_{Ain})
\rightarrow(IP_{Bout},P_{Bout})\)</span></li>
<li>NAT替换目的IP和端口号：<span
class="math inline">\((IP_{Ain},P_{Ain})
\rightarrow(IP_{Bin},P_{Bin})\)</span></li>
<li>B根据收到报文中的源IP和端口号回复A：<span
class="math inline">\((IP_{Bin},P_{Bin})
\rightarrow(IP_{Ain},P_{Ain})\)</span></li>
</ol>
<p>这样做会导致B发往A的回复报文在内网里被转发，没有发向外网，也就没有经过NAT。A会发现回复报文中的源IP<span
class="math inline">\(IP_{Bin}\)</span>和请求报文中的目的IP<span
class="math inline">\(IP_{Bout}\)</span>不一样，导致连接失败。</p>
<p>支持NAT
hairpinning的NAT会注意到一台局域网主机在请求NAT的外部地址，它在替换请求报文目的IP和端口号的同时，也将源IP和端口号替换成A在NAT上的公网IP和端口号，这样B回复A的时候，回复报文就是在请求A的公网IP，这个回复报文又会被NAT做上述替换，看起来就像是从B的公网IP和端口号在回复A：</p>
<ol type="1">
<li>A请求B：<span class="math inline">\((IP_{Ain},P_{Ain})
\rightarrow(IP_{Bout},P_{Bout})\)</span></li>
<li>NAT替换目的IP和端口号，同时替换源IP和端口号：<span
class="math inline">\((IP_{Aout},P_{Aout})
\rightarrow(IP_{Bin},P_{Bin})\)</span></li>
<li>B根据收到报文中的源IP和端口号回复A，这又是内部设备请求外部IP，和第一步对称：<span
class="math inline">\((IP_{Bin},P_{Bin})
\rightarrow(IP_{Aout},P_{Aout})\)</span></li>
<li>NAT替换目的IP和端口号，同时替换源IP和端口号：<span
class="math display">\[(IP_{Bout},P_{Bout})
\rightarrow(IP_{Ain},P_{Ain})\]</span></li>
</ol>
<p>A收到的回复包含正确的源IP和端口号，连接可以成功建立。</p>
<h5 id="nat-hole-punching">NAT Hole-Punching</h5>
<p>NAT使得外部主机无法向NAT后的主机主动发起连接，这既带来了安全，也带来了不便。</p>
<p>解决方案：</p>
<ol type="1">
<li>Connection
Reversal，设NAT后的A与中继服务器R建立了连接，外网设备B要向A发起连接，就先向R发起连接，告知自己想连接A。R通过与A建立的连接将这一信息告知A，A主动发起向B的连接。</li>
<li>Relay，如果A和B都在NAT后怎么办呢？设它们都和中继服务器R保有连接，A和B的通信可以通过R来转发。</li>
</ol>
<p>如果A和B都在NAT之后，只能使用Relay方案，如果想不经过中继服务器转发所有通信，而是直接建立A和B之间的端到端连接，可以使用NAT打孔（Hole-Punching）的方式。</p>
<p>NAT
Hole-Punching同样依赖中继服务器R，不过R不转发任何数据，只是向双方通报彼此的公网IP和端口号（R作为中继服务器，各设备发起连接都要请求它，因此R可以得知它们的公网IP和端口号）。设A通过R向B发起连接：</p>
<ol type="1">
<li>A告诉R，自己要连接B</li>
<li>R将A的公网（IP，端口号）发送给B，将B的公网（IP，端口号）发送给A</li>
<li>A和B同时向对方的公网（IP，端口号）发送垃圾信息，这个垃圾信息会被对方的NAT阻止，但是会穿过己方的NAT，留下自己向对方发送过数据的记录。</li>
<li>现在，A和B向对方发送的报文可以通过对方的NAT了，因为对方曾向自己发送了垃圾信息，对方的NAT会把这些报文视作对这些垃圾信息的回复，并允许其通过。于是A和B之间可以建立端到端连接。</li>
</ol>
<p>注意：上述方案对Symmetric
NAT是不成立的，因为在第3步双方互发消息的时候会使用新的端口号（而不是R所知并告知双方的那个）。</p>
<h5 id="讨论">讨论</h5>
<p>NAT最大的优点显然是IP地址复用，还顺带了一些安全保证（无法主动向NAT后的设备发起连接）。但NAT也带来了问题：它一定程度上破坏了端到端通信的原则，为网络带来了额外的复杂度。</p>
<p>此外，NAT修改IP和端口号的行为一定程度上破坏了分层抽象的原则：IP是网络层的，端口号是传输层的，端口号应该用于区分同一主机上的不同进程，而不是像NAT这样滥用，用在网络层的主机寻址。</p>
<p>此外，NAT需要知道传输层协议的报文格式来更改端口号，这又限制了新的传输层协议的出现：</p>
<ul>
<li><p>新协议流行起来，NAT才会为它做适配，提供支持。</p></li>
<li><p>新协议无法使用NAT，它就流行不起来。</p></li>
</ul>
<p>因此，使用NAT的一个结果是：被广泛使用的传输层协议只有UDP，TCP和ICMP三种。</p>
<h4 id="bittorrent">5-7 BitTorrent</h4>
<p>p2p的文件传输协议，待下载的文件被分片，由一个<code>.torrent</code>文件描述。某一peer
A加入下载时，会先根据<code>.torrent</code>中的信息和tracker通信。tracker追踪了正在参与下载的所有peer，并将其一个子集（比如50个）通知给A，A和它们分别建立连接，称为A的邻居，A的邻居可能是一个变化着的动态集合。</p>
<p>在任意时刻，所有peer均持有所有分片的某一子集。A和邻居们交换信息，告知彼此自己的分片集合。接下来A需要决定两个问题：</p>
<ol type="1">
<li>应该向邻居请求下载哪些分片？在BitTorrent中使用了rarest
first策略，A会请求自己没有的分片里，在邻居中最稀有（数量最少）的那个。这是为了让稀缺的分片尽可能地在网络中被分发，追求所有分片在网络中的数量均衡。</li>
<li>应该响应哪个邻居的下载请求？BitTorrent采用tit-for-tat（“一报还一报”）的策略，A会挑选向自己传输数据最多的P个块（典型值：4），将其置为unchoked状态，其他邻居均为choked状态，只有unchoked的邻居才能从A处下载数据。每隔一段时间，A会随机选取一个邻居B置为unchoked状态进行“试探”，B有机会从A下载数据，因此也有机会向A传输数据，从而成为A新的前P个传输者之一。</li>
</ol>
<p>实现了DHT（Distributed Hash
Table）的BitTorrent没有中心化的tracker，peer地址信息分布式存储在每个参与方的DHT
node那里。</p>
<h4 id="dns">5-8 ~ 5-10 DNS</h4>
<p>DNS查询类型：recursive和iterative，一般主机到本地DNS服务器是recursive，其他查询是iterative。DNS一般使用UDP。</p>
<p>如果一台DNS服务器直接负责解析某主机的IP（而不用查别的DNS），它就是该主机的Authoritative
DNS服务器。比如jw.nju.edu.cn的Authoritative
DNS服务器是dns.nju.edu.cn。</p>
<p>DNS服务器的回复包含一条或多条RR（Resource
Record），RR可以看作一个(Name, Value, Type,
TTL)四元组。常见的类型有：</p>
<ul>
<li><p>Type=A(ipv4)/AAAA(ipv6)，Name是hostname，Value是IP地址</p></li>
<li><p>Type=NS，Name是域名（如nju.edu.cn），Value是存有该域中主机地址的Authoritative
DNS服务器的hostname（如dns.nju.edu.cn），NS记录表明由哪台DNS服务器对该域名做解析。</p>
<p>NS记录可以用来进行iterative的DNS
query。如果<code>dig @dns.edu.cn jw.nju.edu.cn</code>，域edu.cn的dns服务器显然不知道域nju.edu.cn下的主机jw.nju.edu.cn在哪里，于是它会指出域nju.edu.cn的dns服务器是dns.nju.edu.cn（NS记录），和dns.nju.edu.cn的IP（A记录）然后让请求者去查dns.nju.edu.cn。查询结果应包括两条记录：</p>
<ul>
<li>(nju.edu.cn, dns.nju.edu.cn, NS)</li>
<li>(dns.nju.edu.cn, 233.233.233.233, A)</li>
</ul></li>
<li><p>Type=CNAME（canonical
name），Name是别名（如www.baidu.com），Value是规范主机名（如www.a.shifen.com）。</p></li>
<li><p>Type=MX，Name是邮件服务器的别名（电子邮箱的后缀，如nju.edu.cn），Value是邮件服务器名（如mxbiz1.qq.com）。MX让邮件服务器和其他服务器（如Web服务器）可以拥有相同的别名（nju.edu.cn），请求者指定MX时会返回邮件服务器名。</p></li>
</ul>
<h4 id="dhcp">5-11 DHCP</h4>
<p>Dynamic Host Configuration
Protocol用于动态获取IP地址。DHCP使用UDP协议，并使用67和68分别作为服务器和客户端的端口号。</p>
<ol type="1">
<li>DHCP
discover，新加入网络的主机向255.255.255.255:67广播DHCP发现报文。</li>
<li>DHCP
offer，某些DHCP服务器接收到DHCP发现报文，向主机发送（可以是单播或广播）DHCP提供报文，其中包含该服务器打算向主机提供的IP地址。</li>
<li>DHCP
request，主机广播DHCP请求报文，其中包含某一DHCP服务器的IP，代表它向该服务器发出请求。之所以要广播，是为了通知未被选中的其他DHCP服务器不使用它们的服务。</li>
<li>DHCP
ACK，被选中的DHCP服务器向主机发送（可以是单播或广播）DHCP确认报文，交互完成，该主机可以在租期内使用被分配到的IP地址。</li>
</ol>
<h3 id="chapter-6-routing">Chapter 6 Routing</h3>
<h4 id="routing-algorithm">6-1 ~ 6-3 Routing Algorithm</h4>
<p>Routing的方式：</p>
<ul>
<li><p>Flooding，每个路由器都向所有端口转发包（除了包的输入端口），这样做需要用TTL之类的方式解决包的循环问题，且非常低效，一般用于网络结构未知的情形。</p></li>
<li><p>Source
Routing，源端发出的packet包含每一跳的路由器地址。这需要源端了解整个网络的拓扑结构。</p></li>
<li><p>Forwarding
table，每台路由器维护一个转发表，对每个包按照转发表发往下一跳，这是Internet采用的方式。</p></li>
</ul>
<p>寻找转发表的过程就是让网络（一个自治系统，不是Internet）中每个路由器找到一条往其他每个路由器的cost最低的路径。</p>
<p>网络中边权值的定义可以由很多因素决定，如时延，负载程度，安全性等等。</p>
<h5 id="distance-vector-algorithm">Distance-Vector Algorithm</h5>
<p>距离向量算法是分布式的，每个节点与邻居交换信息，迭代执行计算，直至收敛。</p>
<p>Bellman-Ford是一种距离向量算法，每个节点维护：</p>
<ul>
<li>自己到所有目的地的开销估计值，和达到该估计值应选择的下一跳节点，
称为距离向量</li>
<li>每个邻居的距离向量</li>
<li>到每个邻居的链路代价</li>
</ul>
<p>每隔一段时间，每个节点会向邻居发送自己的距离向量。节点根据邻居发来的距离向量更新自己的距离向量，如果有变化，再将变化后的结果发往邻居。这是一个异步过程，不要求所有节点步调一致。</p>
<p>Bellman-Ford有一些问题，如无穷计数：某条链路代价突然增加的“坏消息”在网络中的传播很慢。这是由于两个（或多个）结点不停选择对方作为下一跳而导致的。毒性逆转（poisoned
reverse）使z在z到x的最短路经下一跳是y时，向y通报：z到x的距离是正无穷，以防y选择z作为y到x最短路上的下一跳。这个技术能防止两个节点间的无穷计数，但对多个节点组成的环路上的无穷计数无能为力。</p>
<h5 id="link-state-algorithm">Link-State Algorithm</h5>
<p>链路状态算法中，每个节点不仅与邻居通信，而是会向所有节点通知自己到邻居之间的链路代价，这就导致每个路由器都了解整个网络中的拓扑结构。然后每个节点可以使用Dijkstra最短路算法计算到其他所有节点的单源最短路。</p>
<p>一旦有链路的代价改变，它会被广播到整个网络，所有节点重新计算最短路，因此不存在无穷计数的问题。</p>
<h4 id="rip-ospf-bgp">6-4 ~ 6-5 RIP &amp; OSPF &amp; BGP</h4>
<h5 id="as内路由">AS内路由</h5>
<p>Autonomous
System（AS）是一组处在同一机构管理下的路由器，它们运行相同的路由策略。机构可以自主决定和管理AS内部的路由策略，称为Interior
Routing Protocols。常见的AS内路由策略有OSPF和RIP。</p>
<ul>
<li>RIP是一种距离向量协议，路由器每隔30秒交互一次信息，且信息更新没有鉴权。</li>
<li>现在使用最多的是OSPF，它是一种链路状态协议，每台路由器会广播链路状态。OSPF包含鉴权，防止恶意的OSPF报文影响路由表。OSPF还支持将AS划分为更细粒度的区域，其中包括一个主干区域。链路状态广播局限在区域之内，跨区域的通信要通过主干区域。</li>
</ul>
<p>如果AS只有一个对外的出口，内部路由表很简单，把所有往外部包往出口传就行。如果AS对外的出口不唯一，内部路由器还要考虑应该选择哪个出口。常见的“Hot-potato
routing”策略选择最近的出口（让包尽快离开自己所在的AS），而不考虑这个包离开AS后的传输过程。</p>
<h5 id="as间路由">AS间路由</h5>
<p>跨AS的路由协议是边界网关协议（Border Gateway
Protocol），它不属于距离向量和链路状态协议，称为Path
Vector协议。BGP的任务是确定一个地址前缀（而非具体主机）的可达路径。</p>
<p>如果AS1中含有前缀x，它会向邻居通告“AS1
x”；邻居AS2和AS3收到此信息后又会向它们的邻居通告"AS2 AS1 x"和"AS3 AS1
x"，以此类推，所有AS都会知道一条或多条通向前缀x的具体路径。如果信息中已经包含了自己的ASN，该AS知道出现了环路，它会简单忽视这条信息。</p>
<p>如果通向某个前缀的路径不唯一，AS可以选择采用哪一条路径，并向外传达。一般来说，优先级最高的根据是AS本地策略选择，如果本地策略无法区分，选择AS跳数短的那条。计费，安全性等也是考虑的因素。</p>
<p>总体来说，AS内的路由协议更注重性能，AS间的路由协议更注重满足给定的策略。</p>
<h4 id="multicast">6-6 Multicast</h4>
<p>组播（Multicast）指源端发出的报文被网络复制并送达多个接收方。</p>
<p>最简单的组播实现方式就是flooding，但是网络中存在环路，会让报文无限循环。Reverse
Path
Forwarding（RPF）解决此问题的方式是在每个路由器处根据路由表判断：接收到报文的端口是不是自己向源端发送数据时使用的端口。如果不是则认为这是一个循环报文并丢弃。</p>
<p>RPF相当于确保报文只在以源端为根的Source Distribution
Tree上传播，每个源端对应不同的组播树。也可以选择网络中的路由器作为树根，这样的路由器称为Rendezvous
Point。</p>
<p>主机通过IGMP协议管理组播组，不想接收组播消息的路由器可以把自己从组播树上prune掉。组播路由协议有DVMRP和PIM。</p>
<p>组播实际使用的并不多，看起来很合适的网络直播应用也不是通过组播实现的。<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/65869123">ref</a></p>
<h4 id="spanning-tree-protocol">6-7 Spanning Tree Protocol</h4>
<p>Spanning Tree
Protocol是链路层使用的路由协议。不同于网络层每个源端有自己的生成树，在SPT中，为整个局域网生成唯一的一棵生成树，这是通过Blocking掉交换机上的某些端口来实现的。</p>
<p>局域网中的一台交换机被选为root，其他交换机离root最近的端口称为root
port，需要被邻居使用来到达root的端口称为designated port。只有root
port和designated port可以转发data frame，其他端口置为blocking状态。</p>
<p><img src="/images/CS144/6.png" /></p>
<h3 id="chapter-7-lower-layers">Chapter 7 Lower Layers</h3>
<p>7-1 ~ 7-4 物理层，跳过</p>
<h4 id="ethernet">7-5 &amp; 7-6 Ethernet</h4>
<h5 id="mutiple-access-protocol">Mutiple Access Protocol</h5>
<p>多路访问协议（MAC）规定节点在共享信道下的传输行为，MAC协议需要考虑：</p>
<ul>
<li>链路利用率</li>
<li>节点间公平性</li>
<li>实现难度</li>
<li>Robustness to errors</li>
</ul>
<p>ALOHA：节点有数据就发，检测到冲突就重试。</p>
<ul>
<li>在链路繁忙时利用率不高（大部分发送都是碰撞的）</li>
</ul>
<p>CSMA/CD：节点发送数据前监听信道（Carrier
Sense），空闲时发送。检测到碰撞立刻终止发送（Collision
Detection），等待随机时间（binary exponential
backoff）后回到监听阶段。</p>
<ul>
<li>对报文大小有下限要求：<span class="math inline">\(P \ge
\frac{2LR}V\)</span>，其中<span
class="math inline">\(P\)</span>为报文大小，<span
class="math inline">\(L\)</span>为链路中最长的传输长度，<span
class="math inline">\(R\)</span>为将报文注入链路的速率，<span
class="math inline">\(V\)</span>为链路中报文的传播速度。这是因为最坏情况下某主机需要<span
class="math inline">\(\frac{2L}V\)</span>的时间才能知道自己发出的报文发生了碰撞，此时它必须还没把这个报文发完。</li>
</ul>
<h5 id="ethernet-1">Ethernet</h5>
<p>早期的以太网逻辑上可以看作很多主机连在一条电缆上（物理上可能是用集线器Hub构成星形结构），使用CSMA/CD协议。</p>
<p>现代的千兆/万兆以太网基本都用交换机Switch隔离冲突域，主机直接发数据给Switch，Switch根据转发表转发，已经不再涉及碰撞的问题，可以全双工通信，也就不需要使用CSMA/CD了。但是以太网最小帧这个限制依然保留了下来。</p>
<h4 id="wireless">7-7 ~ 7-11 Wireless</h4>
<p>无线网络和有线网络的主要区别有：</p>
<ul>
<li>信号随着距离增加以平方反比递减。</li>
<li>容易受到干扰。</li>
<li>多径传播：电磁波走多个路径到达同一目标。</li>
<li>隐藏终端：A和C距离远，互不知道对方存在，同时与B通信，在B处造成干扰。</li>
</ul>
<p>无线网络使用CSMA/CA作为MAC协议，其特点是在侦测到信道空闲时也会等待随机时间后再尝试发送，并且引入了链路层ACK确保可靠性。</p>
<p>WiFi（802.11）使用RTS/CTS来解决隐藏终端问题：A首先向B发送RTS（request
to send），B向A回复CTS（clear to
send），同时被C听到：C在这段时间内不发送数据，A向B发送数据。发送完成后，B向A回复ACK，同时C听到ACK之后就知道可以向B发送RTS了。</p>
<h3 id="chapter-8-security">Chapter 8 Security</h3>
<h4 id="intro">8-1 Intro</h4>
<p>网络威胁的类别：</p>
<ol type="1">
<li>Eavesdrop，嗅探网络中传输的数据。
<ul>
<li>监听电缆/光缆</li>
<li>接收WiFi/早期以太网协议广播的报文</li>
<li>控制/欺骗路由器，向攻击者发送报文的复制</li>
</ul></li>
<li>增删改网络中传输的数据。
<ul>
<li>修改包的内容</li>
<li>伪装成正常站点与目标通信</li>
<li>中间人攻击</li>
</ul></li>
<li>阻止目标对某些网络功能的使用。
<ul>
<li>DNS污染</li>
<li>Denal-of-Service Attack</li>
</ul></li>
</ol>
<p>对网络安全的期望：</p>
<ol type="1">
<li>Secrecy/Confidentiality，通过加密使监听者无法理解通信内容</li>
<li>Integrity，保证报文不在中途被篡改</li>
<li>Authentication，确认通信对方的身份</li>
<li>Uninterrupted communication，通信不因外界干扰无法进行</li>
</ol>
<h4 id="layer-2-attacks">8-2 Layer-2 Attacks</h4>
<p>对WiFi和早期以太网，报文被广播，可以将设备网卡置于混杂模式（promiscuous
mode）接收这些报文，实现嗅探。Promiscuous
mode下网卡接收所有经过的数据流，而非仅仅是目的是自身的报文。</p>
<p>在使用了交换机的以太网中，大部分通信是点对点的，不会被广播。Eve可以通过MAC
overflow
attack向网络中的不同地址发送报文，从而导致交换机的转发表溢出，把Alice和Bob之间通信的转发表条目顶掉，使他们的通信被交换机广播出去，从而被嗅探到。</p>
<p>Eve还可以伪造DHCP服务器，并比真正的DHCP服务器更早地回应Alice的DHCP
discover报文，达成让Alice使用伪造的DHCP服务器的目的。因为DHCP服务器还会向主机通报DNS服务器和默认网关的地址，所以Eve还可以向Alice发送伪造的DNS服务器实现DNS劫持，向Alice发送Eve的IP作为默认网关来劫持局域网流量。</p>
<p>Eve还可以发送伪造的ARP回复报文，欺骗Alice和Bob使用Eve的MAC地址和对方通信，实现中间人攻击。</p>
<h4 id="layer-3-attacks">8-3 Layer-3 Attacks</h4>
<p>恶意主机向源主机发送ICMP redirect
message，将其请求重定向到恶意主机。</p>
<p>BGP劫持（通过伪造成ISP，或者侵入BGP
router之间的TCP连接实现；也可能是正规ISP有意/无意为之）：</p>
<ul>
<li>恶意ISP宣称一个不属于自己的prefix属于自己，达成劫持的目的。</li>
<li>恶意ISP发出无效的BGP消息，破坏整个Internet的路由。</li>
<li>恶意ISP通过宣称一个更具体的prefix，拆分某个address
space并破坏其路由。</li>
</ul>
<h4 id="denial-of-service">8-4 Denial of Service</h4>
<p>DoS Amplification：产生比攻击方掌握的资源大得多的攻击效果。</p>
<ul>
<li>利用DNS：DNS回复报文的长度往往远大于请求报文。攻击者在SA字段填写victim的地址，让DNS服务器向victim发送回复报文。</li>
<li>smurf攻击：攻击者在SA字段填写victim地址，向广播地址发送ICMP
echo，让victim被ICMP回复报文淹没。</li>
</ul>
<p>一些DoS的例子，涵盖应用层~网络层：</p>
<ul>
<li>SYN洪泛：攻击者大量发送TCP握手的SYN报文，但不发ACK，让半开的TCP连接占用服务器资源。</li>
<li>IP fragment洪泛：洪泛发送IP packet
fragment，服务器不得不保存状态以等待其他分片。以此浪费资源。</li>
<li>服务端需要对每个SSL连接用公钥解密，攻击者通过建立大量SSL连接消耗服务器的CPU资源。这是在利用某些网络协议在客户端和服务端的处理资源消耗差距很大的特点。</li>
</ul>
<h4 id="confidentiality">8-6 &amp; 8-8 Confidentiality</h4>
<h5 id="symmetric-encryption">Symmetric Encryption</h5>
<p>对称加密指A和B使用同样的密钥K对消息做加解密。</p>
<p>One-Time
Pad是一种理论上完全安全的加密方式：通信双方拥有一个密钥K，它至少与待加密/解密的消息等长。Alice使用K对消息M进行加密（比如异或，<span
class="math inline">\(C = M \oplus K\)</span>），Bob使用K进行解密（<span
class="math inline">\(M = C \oplus
K\)</span>）。然而K只能被使用一次，如果重复使用K加密另一消息会导致泄密，这就是One-Time
Pad得名的原因。考虑<span class="math inline">\(C_1 = M_1 \oplus
K\)</span>，<span class="math inline">\(C_2 = M_2 \oplus
K\)</span>，攻击方可以通过计算<span class="math inline">\(C1 \oplus
C2\)</span>得到<span class="math inline">\(M_1 \oplus
M_2\)</span>，这时信息已经被泄露了（<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/26576521/answer/135803396">Why？</a>）。</p>
<p>One-Time
Pad没有可操作性，因为K需要和消息等长。实践中我们一般会用一个比较短的密钥K，那怎么用K加密比它长的数据呢？这就引入了两种加密方式：流密码（Stream
Cipher）和分组密码（Block Cipher）。</p>
<ul>
<li>流密码根据K生成一个伪随机串（即可根据K唯一确定），用这个伪随机串加密明文。</li>
<li>分组密码把明文分为一个个定长的Block，这样每个Block都可以被K加密。</li>
</ul>
<p>目前实践中使用较多的是分组密码。分组密码中又存在不同的加密模式：</p>
<ul>
<li><p>ECB（Electronic Code
Book），每个block独立地被加密，然后拼到一起。优点是简单可并行，Key可复用。但是攻击者可以根据密文的特征分析出明文的一些模式。（比如明文中重复出现的部分，也会在密文中重复出现）</p>
<p><img src="/images/CS144/7.png" /></p>
<p><img src="/images/CS144/8.png" /></p></li>
<li><p>CBC（Cipher Block
Chaining），引入一个公开的初始向量IV，每次使用K加密不同消息的时候要随机选取不同的IV。加密时每个block的密文不仅取决于自身的明文，也取决于上一个block的密文。这样以来加密过程不能并行了，</p>
<p><img src="/images/CS144/9.png" /></p></li>
<li><p>还有CFB，OFB，CTR等其他模式。</p></li>
</ul>
<h5 id="public-key-cryptography">Public Key Cryptography</h5>
<p>使用公私钥的是非对称加密。非对称加密中各方可以公开自己的公钥，因此对于<span
class="math inline">\(N\)</span>个人的加密通信只需要<span
class="math inline">\(N\)</span>个密钥对（使用对称加密需要<span
class="math inline">\(C_n^2\)</span>个）。但是非对称加密的运算速度远慢于对称加密，因此实践中往往用非对称加密来传递对称加密的密钥。</p>
<p>非对称加密还可以实现数字签名：使用自己的私钥加密M（或<span
class="math inline">\(Hash(M)\)</span>）可以保证M的内容不在签名后被篡改，且只有自己能完成这个签名。任何人都可以用自己的公钥解密签名后的密文进行验证。</p>
<h4 id="integrity">8-7 Integrity</h4>
<p>Confidentiality保证消息不被泄露，但是无法保证恶意方不对消息进行篡改/伪造，这是由Integrity保证的。</p>
<ul>
<li>Cryptographic hash：一个哈希函数，保证难以找到<span
class="math inline">\(x\neq y\)</span>使得<span
class="math inline">\(H(x) =
H(y)\)</span>。可以用来校验报文的完整性，攻击方难以伪造一个哈希值不变的报文。例子：MD5，SHA。</li>
<li>Message Authentication Code：Cryptographic
hash任何人都能做，攻击方可以发出一个假报文并声称这是Alice发出的，让Bob信以为真。如果Alice和Bob有一个共享密钥s，Alice将<span
class="math inline">\((m,
H(m,s))\)</span>传给Bob，Bob就可以在本地计算<span
class="math inline">\(H(m,s)\)</span>，从而验证确实是Alice发出了报文。<span
class="math inline">\(H(m,s)\)</span>就称为Message Authentication
Code。</li>
</ul>
<h4 id="certificate">8-9 Certificate</h4>
<p>为了在通信时确认对方的身份，可以让对方提供签名，并用对方的公钥进行验证。然而这并不能防止中间人攻击：恶意方可以提供自己的签名和自己的公钥进行欺骗。Certificate就是为了解决这一问题。</p>
<p>Certificate是写着“域名N的公钥是<span
class="math inline">\(K_2\)</span>”的文本，并被签发机构用其私钥<span
class="math inline">\(K_1^{-1}\)</span>签名。如果我们信任签发机构并知道其公钥，就可以验证Certificate的正确性，并取得N的公钥。这就形成了一个信任链，上一级证明下一级的公钥真实性，其自身又被更上一级证明。而这个信任链的根证书（即某权威机构的公钥）是被写死在浏览器/操作系统里的。</p>
<h4 id="tls">8-10 TLS</h4>
<p>TLS是建立在TCP之上的会话层协议，被HTTPS使用。TLS的五次握手过程如下：</p>
<ol type="1">
<li>客户端发送一个支持的加密算法的列表，和一个客户端选择的随机数。（非加密）</li>
<li>服务端回复选中的加密算法，服务端选择的随机数以及服务端的证书（证书包含服务端公钥）。（非加密）</li>
<li>客户端验证证书，并生成一个PMS（Pre-Master
Secret）字符串，用服务端的公钥加密PMS并发送。（加密）</li>
<li>双方根据两个随机数和PMS串，使用相同的算法计算出MS（Master-Secret）。</li>
<li>客户端发送所有握手报文的一个MAC。（被MS加密）</li>
<li>服务的发送所有握手报文的一个MAC。（被MS加密）</li>
</ol>
<p>5和6步对整个握手过程的校验防止恶意方篡改了中途某个握手报文。（比如第1步中修改未加密的报文，删除某些复杂的加密算法，留下简单的）</p>
<p>选择随机数的意义：</p>
<ol type="1">
<li>选两个随机数，让客户端和服务端都能为TLS连接引入随机性。</li>
<li>防止重放攻击：恶意方记录客户端的所有握手报文并向服务端发送。有了随机数，服务端生成的MS和上次不同，因此最后的MAC校验无法通过。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2022/03/01/Stanford-CS144-Notes-2/">https://stopire.github.io/2022/03/01/Stanford-CS144-Notes-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/course/">course</a><a class="post-meta__tags" href="/tags/network/">network</a><a class="post-meta__tags" href="/tags/CS144/">CS144</a></div><div class="post_share"><div class="social-share" data-image="/images/post-cover/cover4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/06/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/" title="Linux内存管理-1"><img class="cover" src="/images/post-cover/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内存管理-1</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/13/QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E7%9A%84archlinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/" title="QEMU虚拟机上的archlinux安装记录"><img class="cover" src="/images/post-cover/cover3.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">QEMU虚拟机上的archlinux安装记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report"><img class="cover" src="/images/post-cover/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-16</div><div class="title">CS144 Lab Report</div></div></a></div><div><a href="/2022/01/25/Stanford-CS144-Notes-1/" title="Stanford CS144 Notes(1)"><img class="cover" src="/images/post-cover/cover4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">Stanford CS144 Notes(1)</div></div></a></div><div><a href="/2022/04/05/15-445-Lab-Report/" title="15-445 Lab Report"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">15-445 Lab Report</div></div></a></div><div><a href="/2022/01/23/CMU-15-445-Notes-2/" title="CMU 15-445 Notes(2)"><img class="cover" src="/images/post-cover/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">CMU 15-445 Notes(2)</div></div></a></div><div><a href="/2022/04/11/CMU-15-445-Notes-3/" title="CMU 15-445 Notes(3)"><img class="cover" src="/images/post-cover/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-11</div><div class="title">CMU 15-445 Notes(3)</div></div></a></div><div><a href="/2021/12/15/CMU-15-445-Notes/" title="CMU 15-445 Notes(1)"><img class="cover" src="/images/post-cover/cover4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">CMU 15-445 Notes(1)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter-5-applications-and-nats"><span class="toc-number">1.</span> <span class="toc-text">Chapter 5 Applications and
NATs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#network-address-translation"><span class="toc-number">1.1.</span> <span class="toc-text">5-1 ~ 5-4 Network Address
Translation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nat-hairpinningnat-loopback"><span class="toc-number">1.1.1.</span> <span class="toc-text">NAT hairpinning&#x2F;NAT loopback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nat-hole-punching"><span class="toc-number">1.1.2.</span> <span class="toc-text">NAT Hole-Punching</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bittorrent"><span class="toc-number">1.2.</span> <span class="toc-text">5-7 BitTorrent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns"><span class="toc-number">1.3.</span> <span class="toc-text">5-8 ~ 5-10 DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dhcp"><span class="toc-number">1.4.</span> <span class="toc-text">5-11 DHCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter-6-routing"><span class="toc-number">2.</span> <span class="toc-text">Chapter 6 Routing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#routing-algorithm"><span class="toc-number">2.1.</span> <span class="toc-text">6-1 ~ 6-3 Routing Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#distance-vector-algorithm"><span class="toc-number">2.1.1.</span> <span class="toc-text">Distance-Vector Algorithm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#link-state-algorithm"><span class="toc-number">2.1.2.</span> <span class="toc-text">Link-State Algorithm</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rip-ospf-bgp"><span class="toc-number">2.2.</span> <span class="toc-text">6-4 ~ 6-5 RIP &amp; OSPF &amp; BGP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#as%E5%86%85%E8%B7%AF%E7%94%B1"><span class="toc-number">2.2.1.</span> <span class="toc-text">AS内路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#as%E9%97%B4%E8%B7%AF%E7%94%B1"><span class="toc-number">2.2.2.</span> <span class="toc-text">AS间路由</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multicast"><span class="toc-number">2.3.</span> <span class="toc-text">6-6 Multicast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spanning-tree-protocol"><span class="toc-number">2.4.</span> <span class="toc-text">6-7 Spanning Tree Protocol</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter-7-lower-layers"><span class="toc-number">3.</span> <span class="toc-text">Chapter 7 Lower Layers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ethernet"><span class="toc-number">3.1.</span> <span class="toc-text">7-5 &amp; 7-6 Ethernet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mutiple-access-protocol"><span class="toc-number">3.1.1.</span> <span class="toc-text">Mutiple Access Protocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ethernet-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">Ethernet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wireless"><span class="toc-number">3.2.</span> <span class="toc-text">7-7 ~ 7-11 Wireless</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter-8-security"><span class="toc-number">4.</span> <span class="toc-text">Chapter 8 Security</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#intro"><span class="toc-number">4.1.</span> <span class="toc-text">8-1 Intro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#layer-2-attacks"><span class="toc-number">4.2.</span> <span class="toc-text">8-2 Layer-2 Attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#layer-3-attacks"><span class="toc-number">4.3.</span> <span class="toc-text">8-3 Layer-3 Attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#denial-of-service"><span class="toc-number">4.4.</span> <span class="toc-text">8-4 Denial of Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#confidentiality"><span class="toc-number">4.5.</span> <span class="toc-text">8-6 &amp; 8-8 Confidentiality</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#symmetric-encryption"><span class="toc-number">4.5.1.</span> <span class="toc-text">Symmetric Encryption</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-key-cryptography"><span class="toc-number">4.5.2.</span> <span class="toc-text">Public Key Cryptography</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#integrity"><span class="toc-number">4.6.</span> <span class="toc-text">8-7 Integrity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#certificate"><span class="toc-number">4.7.</span> <span class="toc-text">8-9 Certificate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tls"><span class="toc-number">4.8.</span> <span class="toc-text">8-10 TLS</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/MIT-6-824-Lab-Report/" title="MIT6.824实验记录"><img src="/images/post-cover/cover4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT6.824实验记录"/></a><div class="content"><a class="title" href="/2023/08/14/MIT-6-824-Lab-Report/" title="MIT6.824实验记录">MIT6.824实验记录</a><time datetime="2023-08-13T17:26:41.000Z" title="发表于 2023-08-14 01:26:41">2023-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/05/EROFS%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="EROFS压缩文件格式和读取流程分析"><img src="/images/post-cover/cover5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EROFS压缩文件格式和读取流程分析"/></a><div class="content"><a class="title" href="/2023/07/05/EROFS%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="EROFS压缩文件格式和读取流程分析">EROFS压缩文件格式和读取流程分析</a><time datetime="2023-07-05T10:42:52.000Z" title="发表于 2023-07-05 18:42:52">2023-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/EROFS-A-Compression-friendly-Readonly-File-System-for-Resource-scarce-Devices/" title="EROFS: A Compression-friendly Readonly File System for Resource-scarce Devices"><img src="/images/post-cover/cover4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EROFS: A Compression-friendly Readonly File System for Resource-scarce Devices"/></a><div class="content"><a class="title" href="/2023/05/07/EROFS-A-Compression-friendly-Readonly-File-System-for-Resource-scarce-Devices/" title="EROFS: A Compression-friendly Readonly File System for Resource-scarce Devices">EROFS: A Compression-friendly Readonly File System for Resource-scarce Devices</a><time datetime="2023-05-07T14:14:04.000Z" title="发表于 2023-05-07 22:14:04">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/23/Integrated-Host-SSD-Mapping-Table-Management-for-Improving-User-Experience-of-Smartphones/" title="Integrated Host-SSD Mapping Table Management for Improving User Experience of Smartphones"><img src="/images/post-cover/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Integrated Host-SSD Mapping Table Management for Improving User Experience of Smartphones"/></a><div class="content"><a class="title" href="/2023/03/23/Integrated-Host-SSD-Mapping-Table-Management-for-Improving-User-Experience-of-Smartphones/" title="Integrated Host-SSD Mapping Table Management for Improving User Experience of Smartphones">Integrated Host-SSD Mapping Table Management for Improving User Experience of Smartphones</a><time datetime="2023-03-23T05:51:24.000Z" title="发表于 2023-03-23 13:51:24">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/02/MIT-6-S081-Lab-Report/" title="MIT 6.S081 Lab Report"><img src="/images/post-cover/cover5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT 6.S081 Lab Report"/></a><div class="content"><a class="title" href="/2022/12/02/MIT-6-S081-Lab-Report/" title="MIT 6.S081 Lab Report">MIT 6.S081 Lab Report</a><time datetime="2022-12-01T18:01:19.000Z" title="发表于 2022-12-02 02:01:19">2022-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>