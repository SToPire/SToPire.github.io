<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CMU 15-445 Notes(3) | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CMU Intro to Database Systems (15-445) 2021 class notes, including Lecture 15 ~ Lecture 20.  Lecture 15 Concurrency Control Theory Transaction是对数据库系统中"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2022/04/11/CMU-15-445-Notes-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMU 15-445 Notes(3)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-08 19:59:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/post-cover/cover2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Do not touch fish!</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CMU 15-445 Notes(3)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-10T16:57:10.000Z" title="发表于 2022-04-11 00:57:10">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-08T11:59:56.741Z" title="更新于 2022-10-08 19:59:56">2022-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CMU 15-445 Notes(3)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>CMU Intro to Database Systems (<a
target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/">15-445</a>) 2021 class
notes, including Lecture 15 ~ Lecture 20.</p>
<span id="more"></span>
<h3 id="lecture-15-concurrency-control-theory">Lecture 15 Concurrency
Control Theory</h3>
<p>Transaction是对数据库系统中读写操作的更高一层抽象，代表了“一个单位”的数据库操作<span
class="math inline">\(^{[1]}\)</span>。</p>
<p>Transaction可以表示为对数据库中某些对象的一系列读写操作，由一个BEGIN标记txn的开始，ABORT或者COMMIT标记txn的结束。</p>
<p>Transaction应该具有ACID（Atomicity，Consistency，Isolation，
Duration）的特性。</p>
<h4 id="atomicity">Atomicity</h4>
<p>事务应该是原子的，即要么事务中的全部操作全部完成，要么全部未完成。</p>
<p>达成Atomicity的方式：</p>
<ol type="1">
<li>Logging（主流），DBMS记录所有的操作，可以用来在从crash恢复后撤销完成了一半的事务。</li>
<li>Shadow
Paging，对事务需要修改的数据页进行copy，事务在copy上进行修改，提交时再用copy替换掉原来的页。</li>
</ol>
<h4 id="consistency">Consistency</h4>
<p>Consistency描述数据库在逻辑上的正确性。如果数据库在执行事务之前是一致的，且执行完事务后也是一致的，则该事务具有一致性。</p>
<h4 id="isolation">Isolation</h4>
<p>Isolation指所有事务的执行不受其他事务的影响，就好像它们独自在DBMS中被执行一样。让所有事务顺序执行显然可以达到Isolation，但出于性能考虑，DBMS往往允许事务并行执行，并采用Concurrency
Control确保Isolation。Concurrency Control
Protocol的任务就是生成与顺序执行等价的执行序列（事务有很多，顺序执行可能有很多种，与其中任何一种等价即可）。</p>
<p>Concurrency Control Protocol可分为乐观和悲观两类：</p>
<ol type="1">
<li>Pessimistic，假设事务并行执行一定会冲突，于是采取措施（如加锁）不让冲突发生。</li>
<li>Optimistic，假设事务并行执行中发生的冲突不多，于是在事务COMMIT后处理可能发生的冲突（如回滚事务）。</li>
</ol>
<p>冲突（Conflict）定义为：从属于不同事务的操作作用于同一个对象，且其中至少一个为写操作。冲突的类型有：</p>
<ol type="1">
<li>Read-Write Conflicts (“Unrepeatable
Reads”)：先读后写，事务1读对象后，事务2修改该对象，事务1再次读该对象发现结果与第一次读到的不同，称为不可重复读。</li>
<li>Write-Read Conflicts (“Dirty
Reads”)：先写后读，事务1写对象后，事务2读该对象，之后事务1被撤销，但事务1的修改被事务2读到了，称为脏读。</li>
<li>Write-Write conflict (“Lost
Updates”)：事务1写对象后，事务2再次写该对象，导致事务1的写入被覆盖。</li>
</ol>
<h5 id="等价性">等价性</h5>
<p>前面提到Concurrency Control
Protocol要能够生成与顺序执行“等价”的执行序列，所谓“等价”有三种定义：</p>
<ul>
<li>final state equivalent，两种执行序列是final state
equivalent的，当且仅当对数据库任意的初始状态，两种序列能够使数据库转移到相同的最终状态。</li>
<li>view equivalent，两种执行序列是view
equivalent的，当且仅当两种序列中所有“读取”操作读到数据的来源（即来自于某个事务中某次“写入”操作，或是来自于初始状态）一样，且每个数据库对象的最后一次写入操作所处的事务也一样。
说人话：两种执行序列中，每个事务执行过程中“看到”的数据库状态是一样的。</li>
<li>conflict equivalent，两种执行序列是conflict
equivalent的，当且仅当两种序列中每对冲突（Conflict）操作的先后顺序都是一样的。</li>
</ul>
<p>如果一个执行序列<span
class="math inline">\(S_1\)</span>与顺序执行序列<span
class="math inline">\(S_2\)</span>{final state, view, conflict}
equivalent，则称<span class="math inline">\(S_1\)</span>具备{final
state, view, conflict} serializability。</p>
<p>以上三种定义按照从弱到强排序，serializability程度越强，牺牲的并发程度就越多，并发性能就越差。</p>
<p>要保证Consistency，达到view
serializability就足够了。但是检查一个执行序列是否为view
serializability是一个NP-complete问题，所以实际的DBMS中绝大部分都是以牺牲一部分并发程度为代价，采用conflict
serializability。Conflict serializability可以通过dependency
graph来检查。</p>
<p>这部分可以参照引文[1]的详细描述。</p>
<h4 id="durability">Durability</h4>
<p>所有提交成功的事务都必须被DBMS持久化存储，即crash之后它们不会消失。</p>
<h3 id="lecture-16-two-phase-locking">Lecture 16 Two-Phase Locking</h3>
<p>DBMS中会使用锁（lock）来在不事先知道事务具体读写对象过程的情况下，保证事务的(conflict)
serializability。锁保护的是数据库对象，它们由数据库中一个中心化的lock
manager所管理。按照锁的排他性可以分为：</p>
<ul>
<li>Shared
Lock（S-Lock），允许多个事务读同一个对象。如果一个事务拿了某对象的S-Lock，其他事务也可以拿到该S-Lock。</li>
<li>eXclusive
Lock（X-Lock），允许事务写对象。如果一个事务拿了某对象X-Lock，其他事务都拿不到该对象上的S-Lock或X-Lock。</li>
</ul>
<p>为了保证conflict
serializability，DBMS需要在事务的读写序列中插入一系列lock和unlock操作，在读/写对象时必须先拿到对应的锁。事务提出的lock请求可能会被lock
manager同意或拒绝，如果被拒绝，它必须等待其他事务释放该锁。</p>
<h4 id="pl">2PL</h4>
<p>Two-Phase Locking（2PL）是一种基于锁的悲观concurrency control
protocol。它的思想是：一旦某事务释放了它所持有的任何一个锁，它就不能再获得任何锁。因此每个事务的执行过程都可以分为growing和shrinking两个阶段，其持锁数量分别单调不减和单调不增。</p>
<p>2PL可以保证conflict
serializability，即保证所有冲突操作的顺序。反证法证明：</p>
<ol type="1">
<li>假设某遵循2PL的执行序列不满足conflict serializability，则dependency
graph中必存在环。</li>
<li>对环中每条边<span class="math inline">\(T_i \rightarrow
T_j\)</span>，<span class="math inline">\(T_i\)</span>和<span
class="math inline">\(T_j\)</span>中必存在一对冲突动作，并且<span
class="math inline">\(T_i\)</span>中的动作先执行，<span
class="math inline">\(T_j\)</span>中的动作后执行。</li>
<li>假设这对冲突动作操作的对象是<span
class="math inline">\(O\)</span>，一定是<span
class="math inline">\(T_i\)</span>一定先释放<span
class="math inline">\(O\)</span>上的锁，<span
class="math inline">\(T_j\)</span>后获取<span
class="math inline">\(O\)</span>上的锁。</li>
<li>由2PL的性质可以得出：一定是<span
class="math inline">\(T_i\)</span>先进入了shrinking阶段，<span
class="math inline">\(T_j\)</span>才完成了growing阶段。</li>
<li>上述结论对环中每条边都成立，即若环中存在边<span
class="math inline">\(T_j \rightarrow T_k\)</span>，可推出<span
class="math inline">\(T_j\)</span>先进入了shrinking阶段，<span
class="math inline">\(T_k\)</span>才完成了growing阶段。于是传递得到：一定是<span
class="math inline">\(T_i\)</span>先进入了shrinking阶段，<span
class="math inline">\(T_k\)</span>才完成了growing阶段。</li>
<li>结论传递完整个环，得出结论：一定是<span
class="math inline">\(T_i\)</span>先进入了shrinking阶段，<span
class="math inline">\(T_i\)</span>才完成了growing阶段。这显然是荒谬的，故假设不成立，满足2PL的执行序列一定满足conflict
serializability。</li>
</ol>
<h4 id="rigorous-2pl">Rigorous 2PL</h4>
<p>2PL会导致cascading aborts：</p>
<ol type="1">
<li>事务1写入了对象<span
class="math inline">\(O\)</span>后，事务2读了对象<span
class="math inline">\(O\)</span>。</li>
<li>如果此时事务1被abort，则事务2不得不也被终止。因为事务2读到的对象<span
class="math inline">\(O\)</span>的值来自一个被abort的事务。</li>
</ol>
<p>事务2被终止可能会让更多的事务被迫终止，导致雪崩，所以称为cascading
aborts。这本质是一个dirty read的问题。</p>
<p>解决方法是以牺牲更多并发程度为代价，采用更严格的2PL策略：Strong
Strict 2PL（又名Rigorous
2PL），它保证事务所持有的所有锁都在事务被commit时一起释放。这样一来其他事务不可能读到脏值。</p>
<h4 id="deadlock">Deadlock</h4>
<p>2PL不能避免死锁，因为两个事务可能以相反的顺序拿某两个同样对象上的锁。DBMS可以采取死锁检测和死锁避免的方式解决死锁问题。</p>
<p>死锁检测（deadlock detection）：DBMS维护一张等待图（wait-for
graph），如果<span class="math inline">\(T_i\)</span>在等待<span
class="math inline">\(T_j\)</span>持有的锁，则存在一条从<span
class="math inline">\(T_i\)</span>指向<span
class="math inline">\(T_j\)</span>的边。一旦等待图中出现环，就说明出现了死锁。DBMS需要选中一个事务，并将其全部或部分回滚，破坏等待图中的环。</p>
<p>死锁避免（deadlock
prevention）：DBMS保证拿锁的顺序，防止死锁的发生。当一个事务请求另一个事务持有的锁时，DBMS可能会abort其中一个事务来避免死锁。</p>
<ul>
<li>Wait-Die ("Old Waits for Young")：设<span
class="math inline">\(T_1\)</span>比<span
class="math inline">\(T_2\)</span>先开始，如果<span
class="math inline">\(T_1\)</span>请求了<span
class="math inline">\(T_2\)</span>持有的锁，<span
class="math inline">\(T_1\)</span>进入等待；如果<span
class="math inline">\(T_2\)</span>请求了<span
class="math inline">\(T_1\)</span>持有的锁，<span
class="math inline">\(T_2\)</span>被终止。这是非抢占的策略，因为已经持锁的事务不会被终止。</li>
<li>Wound-Wait ("Young Waits for Old")：设<span
class="math inline">\(T_1\)</span>比<span
class="math inline">\(T_2\)</span>先开始，如果<span
class="math inline">\(T_1\)</span>请求了<span
class="math inline">\(T_2\)</span>持有的锁，<span
class="math inline">\(T_2\)</span>被终止；如果<span
class="math inline">\(T_2\)</span>请求了<span
class="math inline">\(T_1\)</span>持有的锁，<span
class="math inline">\(T_2\)</span>进入等待。这是抢占的策略，因为已经持锁的事务可能被抢锁，而自己被终止。</li>
</ul>
<p>Wait-Die和Wound-Wait两种方法本质相同，都是控制了事务间等待的顺序（老等少/少等老），如出现与等待顺序相反的锁请求，会导致年轻的事务被终止。PS：被终止的事务如果重启，应该沿用之前的时间戳。否则它每次重启都变得更年轻，可能被新来的事务一直欺负。</p>
<h4 id="lock-granularity">Lock Granularity</h4>
<p>如果锁的粒度太小，我们需要拿很多次锁才能完成操作（比如扫描一亿个tuple的表，需要拿一亿个元组上的锁）。可以把不同对象的锁组织成一个树状结构（比如table锁的后代是tuple锁，tuple锁的后代是attr锁），拿了上层的锁就等于隐式地拿了其后代锁。</p>
<p>然而这样一来，上锁操作就变得更加复杂了——不仅需要检查当前锁，还需要检查其所有祖先和所有后代，以此判断新加的锁是否会与其祖先和后代中任何一个已经被持有的锁冲突。于是引入了意向锁（Intention
lock）的概念：</p>
<ul>
<li>IS，若事务对某节点上了IS锁，说明它会显式地对某个子节点上S锁。</li>
<li>IX，若事务对某节点上了IX锁，说明它会显式地对某个子节点上X锁。</li>
<li>SIX，相当于S锁和IX锁的结合，该节点被同时上了S锁和IX锁。虽然两个事务不能分别持有S锁和IX锁，但是对一个事务而言，既持有S锁也持有IX锁也不会带来正确性问题，所以引入了SIX锁的概念。</li>
</ul>
<p>意向锁的相容性矩阵（即两个事务分别试图持有某对象的锁的相容性情况）：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="even">
<td>X</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="odd">
<td>IS</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="even">
<td>IX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr class="odd">
<td>SIX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>解释：</p>
<ol type="1">
<li>节点持S锁，其所有子节点都不能上X锁，所以与X，IX，SIX不相容。</li>
<li>节点持X锁，其所有子节点不能上任何锁，所以与所有锁不相容。</li>
<li>节点持IS锁，其某个子节点会上S锁，因此与X不相容。但是可以与IS，IX，SIX相容，因为其持X锁的子节点不一定就是持S锁的子节点。</li>
<li>节点持IX锁，其某个子节点会上X锁，因此与S，X，SIX不相容。但是可以和IS，IX相容，因为其持X锁的子节点不一定就是持S锁的子节点。</li>
<li>节点持SIX锁，取S和IX相容情况的交集，即只与IS锁相容。</li>
</ol>
<h3 id="lecture-17-timestamp-ordering">Lecture 17 Timestamp
Ordering</h3>
<p>Timestamp ordering（T/O）是一种乐观的concurrency
protocol，它使用时间戳来保证事务的serializability order。</p>
<p>每个事务会被指定一个单调递增的Timestamp（TS），如果<span
class="math inline">\(TS(T_i) &lt;
TS(T_j)\)</span>，DBMS必须保证执行序列与一个<span
class="math inline">\(T_i\)</span>在<span
class="math inline">\(T_j\)</span>之前执行的顺序执行序列等价。TS可能是当前时间，也可能是一个逻辑计数器，也可能是它们的混合。</p>
<h4 id="basic-timestamp-orderingbasic-to">Basic Timestamp
Ordering（BASIC T/O）</h4>
<p>BASIC T/O为每个数据库对象<span
class="math inline">\(X\)</span>维护两个值：<span
class="math inline">\(RTS(X)\)</span>和<span
class="math inline">\(WTS(X)\)</span>，分别记录最后一个读/写此对象的事务的时间戳。事务在读写每个对象前都要检查是否违反了Timestamp
order，如果违反则终止并重启当前事务。</p>
<p>读操作：</p>
<ul>
<li>如果<span class="math inline">\(TS(T_i) \lt
RTS(X)\)</span>，说明违反了Timestamp order（<span
class="math inline">\(T_i\)</span>试图读一个未来才会被写入的值），此时<span
class="math inline">\(T_i\)</span>被abort，并以新的时间戳重新被执行。</li>
<li>否则，读操作可以成功执行，更新<span class="math inline">\(RTS(X) =
max(RTS(X), TS(T_i))\)</span>。</li>
</ul>
<p>写操作：</p>
<ul>
<li>如果<span class="math inline">\(TS(T_i) \lt RTS(X)\)</span> 或者
<span class="math inline">\(TS(T_i) \lt
WTS(X)\)</span>，说明违反了Timestamp order（<span
class="math inline">\(T_i\)</span>没有在被使用之前写入它应该写入的值），此时<span
class="math inline">\(T_i\)</span>被abort，并以新的时间戳重新被执行。</li>
<li>否则，写操作可以成功执行，更新<span class="math inline">\(WTS(X) =
TS(T_i)\)</span>。</li>
</ul>
<p>优化（Thomas write rule）：</p>
<ul>
<li>写操作时如果满足<span class="math inline">\(TS(T_i) \lt
WTS(X)\)</span>且不满足<span class="math inline">\(TS(T_i) \lt
RTS(X)\)</span>，可以不终止并重启<span
class="math inline">\(T_i\)</span>，而只是忽略这次写操作（因为这次写操作被覆盖了，并且没有其他事务读这个被覆写的数据）。</li>
</ul>
<p>如果不使用Thomas write rule，BASIC T/O生成的执行序列是conflict
serializable的。它的缺点有：</p>
<ol type="1">
<li>执行时间较长的事务因为与频繁到来的新事务冲突而被反复重启，造成饥饿。</li>
<li>分配时间戳在高并发情景下成为瓶颈。</li>
</ol>
<h4 id="optimistic-concurrency-control-occ">Optimistic Concurrency
Control （OCC）</h4>
<p>OCC在事务之间冲突较少的情况下效果很好（如所有事务都是读操作，或每个事务都操作数据库的一个划分，相互没有交集）。</p>
<p>在OCC下，DBMS为每个事务创建私有空间，读操作会把对象copy到私有空间中，写操作会操作私有空间中的对象。事务提交时，DBMS检查当前事务的提交是否与其他事务冲突，如果不冲突才会把更改update到数据库中。</p>
<p>OCC把每个事务分为3个阶段：</p>
<ol type="1">
<li>Read Phase，（在私有空间中）进行事务中的读写操作。之所以叫Read
Phase，是因为数据库在这个阶段只是被读取。</li>
<li>Validation Phase，验证待提交的当前事务是否与其他事务冲突。</li>
<li>Write Phase，将事务的修改从私有空间同步到数据库中。</li>
</ol>
<p>OCC的缺点有：</p>
<ol type="1">
<li>validation阶段需要读别人的私有空间，看看别人都干了啥。这在物理上（latch层面）会导致对某些数据结构的高争用。</li>
<li>在私有空间和数据库之间的拷贝动作会带来开销。</li>
<li>事务被终止的代价会很大。因为事务只可能在Validation阶段被终止，此时事务的读写操作已经完成了，它们全白做了。</li>
<li>分配时间戳在高并发情景下成为瓶颈。</li>
</ol>
<h4 id="隔离级别">隔离级别</h4>
<p>幻读（Phantom
Read）：插入/删除操作导致范围查询语句（如MAX）作用于旧的元组集合，导致错误。</p>
<p>解决幻读问题的方法有：</p>
<ol type="1">
<li>Re-Execute
Scan，对于事务中的范围查询操作，在事务commit之前重新扫描一下，看结果是不是发生了变化。想法很trivial，性能不佳。</li>
<li>谓词锁（Predicate
Locking），对SELECT语句中的WHERE子句上共享锁（S），对UPDATE/INSERT/DELETE等语句种的WHERE子句上排他锁（X），不让范围查询涉及到的元组集合被修改（即插入/删除元组）。</li>
<li>索引锁（Index
Locking），对范围查询中谓词涉及到的属性所在的索引页上锁（如果这个属性上没索引，只能锁table了），防止相关元组被插入/删除。</li>
</ol>
<p>SQL-92标准定义了4种隔离级别：</p>
<table>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>READ-COMMITTED</td>
<td>X</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>REPEATABLE READS</td>
<td>X</td>
<td>X</td>
<td>√</td>
</tr>
<tr class="even">
<td>SERIALIZABLE</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>之前讨论的2PL，T/O等concurrency
protocol都是为了实现SERIALIZABLE，即事务间的完全隔离。隔离级别降低以后，事务间不再是完全独立的，而是会互相影响，但同时性能也得到提高。</p>
<p>实现各隔离级别的方式：</p>
<ol type="1">
<li>SERIALIZABLE：strict 2PL（或T/O concurrency protocol） + Index
Lock</li>
<li>REPEATABLE READS：strict 2PL（或T/O concurrency protocol）</li>
<li>READ-COMMITTED：(not strict)
2PL，且S锁会被立刻释放。这就导致可能出现unrepeatable read。</li>
<li>READ-UNCOMMITTED：(not strict) 2PL，去掉S锁。这就导致可能出现dirty
read。</li>
</ol>
<h3 id="lecture-18-multi-version-concurrency-control">Lecture 18
Multi-Version Concurrency Control</h3>
<p>MVCC是一种概念，涉及到数据库涉及与实现的多个方面，而不仅仅是一种并发控制协议。MVCC的基本思想是对数据库中同一个逻辑对象维护多个物理版本，写操作会创建新版本的对象，而读操作会读到事务开始时存在的最新版本的对象。</p>
<p>MVCC可以让reader和writer之间不相互阻塞，因为每个reader看到的都是数据库在某一时刻的snapshot，该时刻之后的修改对该reader不可见。此外MVCC可以很自然地支持time-travel
query，即在某一时刻的数据库snapshot中进行query。</p>
<p>MVCC的重要design decision有：</p>
<ol type="1">
<li>concurrency control protocol（就是之前lecture的2PL，T/O等等）</li>
<li>version storage</li>
<li>garbage collection</li>
<li>index management</li>
</ol>
<h4 id="version-storage">Version Storage</h4>
<p>version storage决定数据库如何管理一个对象的不同版本。DBMS使用version
chain以链表的形式将对象的不同版本串联起来。</p>
<ol type="1">
<li>append-only
storage，一张表中所有tuple的不同版本全都混杂在一起，写入的时候就在表后面追加，然后update链表指针。</li>
<li>time-travel
storage，表中只维护每个tuple的最新版本，并且每个tuple有一个指针指向其历史版本的链表。</li>
<li>delta storage，与time-travel
storage类似，不过历史版本不是完整的tuple，而是每次修改变化的部分。这样写操作更快，但是读历史版本更慢，因为需要逐步重建历史tuple。</li>
</ol>
<p>链表可以从最新指向最老（N2O），也可以反过来（O2N），但对于delta
storage显然只能N2O，不然没法重建历史版本。</p>
<h4 id="garbage-collection">Garbage Collection</h4>
<p>DBMS需要清理无用的历史版本。</p>
<ol type="1">
<li>tuple-level，即定期检查并清理无用的tuple。分为：
<ul>
<li>Background：单独的清理线程遍历table，并结合当前active事务的timestamp判断哪些历史版本可以被回收。DBMS可以将上一次垃圾回收以来被修改过的元组所在的页标记为脏页，以避免遍历所有页中的元组。</li>
<li>Cooperative：每个工作线程通过version
chain访问相应tuple时就顺便清理不用的历史版本。只适用于O2N的version
chain。</li>
</ul></li>
<li>transaction-level，每个事务维护自己读写导致的历史版本，并传给garbage
collector，不需要逐tuple检查。</li>
</ol>
<h4 id="index-management">Index Management</h4>
<p>MVCC会产生很多不同版本的对象，因此version
chain的变动是比较频繁的。</p>
<p>主键索引（primary index）直接指向每个tuple的version
chain的头部（即物理地址），如果version
chain发生变化，就需要更新主键索引指向的指针。</p>
<p>非主键索引（secondary index）就有不同设计思路了：</p>
<ol type="1">
<li>可以和primary index一样直接指向物理地址（查一次，version
chain更新时需要update所有secondary index）</li>
<li>也可以指向一个逻辑id，如primary
key，再根据该逻辑id去查一次主键索引得到想要的tuple（多查一次，但是update方便，只要更新主键索引中的指针）。</li>
</ol>
<h3 id="lecture-19-logging-schemes">Lecture 19 Logging Schemes</h3>
<p>Recovery算法的目标是保证数据库crush之后的一致性、事务原子性和持久性，它由两个部分组成：</p>
<ul>
<li>正常事务处理逻辑中做出的操作，确保DBMS在crush之后可恢复。</li>
<li>DBMS
crush之后做出的操作，将数据库恢复到一个一致的状态，这包括撤销未提交事务的影响（UNDO）和确保已提交事务正确落盘（REDO）。</li>
</ul>
<p>数据库Failure可分为：</p>
<ol type="1">
<li>Transaction Failure，某事务执行失败，可能因为：
<ul>
<li>逻辑错误，比如试图插入不符合表约束的tuple。</li>
<li>状态错误，比如产生死锁，DBMS不得不杀死一个事务来解决死锁。</li>
</ul></li>
<li>System
Failure，包括软件方面（DBMS有bug）和硬件方面（插头被拔了）。在讨论Recovery时，我们假设断电会导致内存中数据全部丢失，而磁盘中已落盘的数据不会被破坏。</li>
<li>Storage Media
Failure，如硬盘坏了导致数据丢失，这就不属于数据库能恢复的failure了。</li>
</ol>
<h4 id="buffer-pool-policies">Buffer Pool Policies</h4>
<p>DBMS在管理Buffer
Pool和disk之间数据同步时，可以针对Runtime（正常运行）和Recovery时的性能，采取不同的trade
off。</p>
<p>steal：是否允许事务将尚未提交的数据持久化到disk中？</p>
<p>force：事务是否必须在COMMIT之前将其所有修改落盘？</p>
<p>采用No-steal +
force策略时，Runtime性能最差，Recovery性能最好。事实上，这种策略下根本不需要recovery，因为未提交的事务不可能持久化其修改，已提交的事务一定已经将修改落盘。</p>
<p>作为代价，该策略：</p>
<ol type="1">
<li>每次提交事务前都要写磁盘，影响性能。</li>
<li>每个事务修改的规模受到内存缓冲区限制，因为不允许将尚未提交的数据落盘。</li>
<li>如果两个事务修改了同一磁盘页的不同位置，DBMS不能一次将该页落盘（因为事务提交总有先后），而必须把修改分两次先后落盘，造成写放大。</li>
</ol>
<h4 id="shadow-paging">Shadow paging</h4>
<p>shadow paging是一种No-steal +
force策略的实现。它把数据库维护master和shadow两个副本，分别代表已经提交的事务（已经落盘）的数据和未提交事务修改的数据。所有未提交事务都在shadow中做修改，事务提交时会让shadow成为新的master。</p>
<p>实现中，不需要将整个数据库拷贝成两份，只要对有修改的页维护两个副本即可（类似COW）。shadow
page是在内存中的，但它们可能被buffer pool
manager隐式交换到磁盘上，好处是事务修改规模可以突破缓冲区上限，坏处是事务执行过程中就可能发生flush影响性能，且容易造成磁盘碎片。另外，shadow
paging不能处理两个以上写事务并行的情况。</p>
<h4 id="write-ahead-logging">Write-Ahead Logging</h4>
<p>WAL是应用最广泛的Recovery方法，它是指DBMS在把buffer
pool中修改过的页刷回之前，必须先记一个log，并把log刷到磁盘。</p>
<p>log被记录在内存中，并且不同事务的log不会分开，是交错记录的。事务提交时把该事务涉及到的log页落盘，且一旦日志落盘，就认为事务COMMIT已经成功。一种优化是事务提交时等待一会，等到几个事务都要提交时再一起写入它们的log，减少写盘次数。</p>
<p>WAL中一般使用Steal +
No-force的方式，最大化运行时性能，但是在recovery时就需要根据log重放操作。</p>
<p>日志中一般记录：事务BEGIN，事务COMMIT，每个操作的事务ID，对象ID，操作之前的值（用于Undo），操作之后的值（用于Redo）。</p>
<h4 id="logging-scheme">Logging Scheme</h4>
<p>根据日志记录的内容可以分为：</p>
<ul>
<li>physical
logging，字节粒度，对每个操作，记录所有修改处的变化（类似<code>git diff</code>）。比如某页某偏移处从A值变为B值。</li>
<li>logical logging，只是在high
level记录每个操作，比如把执行的SQL语句记录下来。</li>
</ul>
<p>logical
logging占用的空间更小，但是恢复时需要重建每个动作的影响，恢复更慢；此外对于并行事务无能为力，因为无法还原当时的并发调度情况。</p>
<p>一种折衷是两者的混合Physiological Logging，它类似physical
logging，但是不会具体到偏移量，只是用到page number和slot
number索引。这就使得DBMS碎片整理时（比如将数据页中的空隙补上，导致偏移量变化）不需要修改每个log中的偏移量。</p>
<h4 id="checkpoint">Checkpoint</h4>
<p>DBMS会在日志里插入一些checkpoint，该点之前提交的事务已经被持久化，crash恢复只需要从最近的checkpoint开始即可，不用从头开始遍历整个WAL。</p>
<h3 id="lecture-20-aries-database-recovery">Lecture 20 ARIES Database
Recovery</h3>
<p>Algorithms for Recovery and Isolation Exploiting Semantics
（ARIES）是IBM提出的Recovery算法，主要的思想有：</p>
<ol type="1">
<li>write ahead logging，且buffer pool策略是steal + no-force。</li>
<li>Redo时根据log将数据库恢复到crash之前的状态。</li>
<li>Undo时做的操作也需要记录，防止crash之后又chash导致撤销时的操作被重复执行。</li>
</ol>
<p>ARIES使用的WAL记录有一个额外字段：全局唯一且单调递增的Log Sequence
Number（LSN），作为每条日志的ID。同时DBMS需要维护一些关于LSN的额外元数据：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Where</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>flushedLSN</td>
<td>memory</td>
<td>最后一个被flush到磁盘上的LSN</td>
</tr>
<tr class="even">
<td>pageLSN</td>
<td>each page</td>
<td>最后一个操作该页数据的LSN</td>
</tr>
<tr class="odd">
<td>recLSN</td>
<td>each page</td>
<td>该页上一次被flush到磁盘之后，第一个操作该页数据的LSN</td>
</tr>
<tr class="even">
<td>lastLSN</td>
<td>each transaction</td>
<td>该事务中最后一条日志的LSN</td>
</tr>
<tr class="odd">
<td>MasterRecord</td>
<td>disk</td>
<td>最后一个checkpoint的LSN</td>
</tr>
</tbody>
</table>
<p>任何一页被持久化到磁盘之前，必须保证涉及该页的log也被持久化，即<span
class="math inline">\(pageLSN_i &lt; flushedLSN\)</span>。</p>
<h4 id="normal-execution">Normal Execution</h4>
<p>在讨论事务的正常执行流程时，本课程基于以下的假设：</p>
<ul>
<li>所有日志不超出一页大小，因此落盘是原子操作。</li>
<li>tuple是single-version的，并使用strict 2PL并发策略。</li>
<li>buffer pool策略是steal + no-force。</li>
</ul>
<p>COMMIT流程：</p>
<ol type="1">
<li>在WAL中记录COMMIT日志。</li>
<li>将COMMIT日志及之前的日志落盘。</li>
<li>将事务已成功提交的信息返回给用户。</li>
<li>在WAL中记录TXN-END日志。（不需要立刻落盘）</li>
</ol>
<p>COMMIT日志只代表数据库向用户返回了成功提交，其内部还维护着该事务的元信息和一些数据结构；TXN-END日志代表在数据库内部，对该事务的处理已经完成，后续的日志中不会再出现和该事务相关的信息。</p>
<p>ABORT时是把之前的修改回退，也是对数据库的修改，因此也需要记日志，称为Compensation
Log
Records（CLR）。CLR和正常日志一样，但是多出一个字段undoNextLSN，表示下一个需要回退的操作的LSN。同时，每条日志也会维护previous
LSN指针，指向属于该事务的上一条记录，相当于维护了一个反向链表。这样ABORT时就不需要每次遍历日志寻找下一个需要回退的操作（即属于该事务的上一个操作），顺着反向链表走就行。</p>
<p>ABORT流程：</p>
<ol type="1">
<li>在WAL中记录ABORT日志，并将事务已经ABORT的信息返回给用户。</li>
<li>反向遍历当前事务的日志，撤销每个操作并记录CLR日志。</li>
<li>完成后，在WAL中记录TXN-END日志。</li>
</ol>
<p>注意ABORT日志不需要立刻落盘，且通知用户ABORT也不需要等待所有回滚操作做完。就算ABORT到一半crash了，下次重启后DBMS发现这个事务没做完，它会（在Undo中）重新开始回滚。因此，在ARIES中，可以把ABORT操作看作Undo作用于一个事务的特例。</p>
<h4 id="checkpoint-1">Checkpoint</h4>
<p>传统的checkpoint需要DBMS停止处理当前已经开始的事务，停止接收新事务，然后再将所有脏页落盘并记录checkpoint。</p>
<p>ARIES使用fuzzing
checkpoint的策略，允许DBMS在记录checkpoint时，其他事务正常执行。引入两个数据结构：</p>
<ul>
<li>Active Transaction
Table（ATT），记录当前时间点所有活跃（即：未TXN-END）的事务。每个表项包括txnID，txnStatus和lastLSN（该事务最后一条日志的LSN）。</li>
<li>Dirty Page
Table（DPT），记录当前时间点所有脏页，每个条目包括脏页的ID和recLSN值。</li>
</ul>
<p>首先，checkpoint不再是一个点，而是由CHECKPOINT-BEGIN和CHECKPOINT-END标示出的一段区间。CHECKPOINT-BEGIN处根据当前数据库的状态得出ATT和DPT，然后开始将所有非脏页落盘（与此同时，事务正常进行）。完成flush后记录CHECKPOINT-END日志，并在CHECKPOINT-END日志中带上ATT和DPT。MasterRecord指针指向最后一个CHECKPOINT-BEGIN处。</p>
<h4 id="recovery">Recovery</h4>
<p>ARIES恢复过程由3个部分组成：</p>
<ol type="1">
<li>Analysis，根据WAL得出在crash发生的时间点，尚未TXN-END事务的状态（ATT）和尚未flush的脏页（DPT）。</li>
<li>Redo，从日志中某个位置开始，重放每个操作。</li>
<li>Undo，回退crash发生时没有提交的操作。</li>
</ol>
<h5 id="analysis">Analysis</h5>
<p>从最后一个CHECKPOINT-BEGIN处向后遍历WAL，并从CHECKPOINT-END处读到ATT和DPT：</p>
<ol type="1">
<li>遇到一个TXN-END，将该事务从ATT中删除。</li>
<li>遇到一个COMMIT，将该事务的状态改为C（Commited）。</li>
<li>遇到其他类型的记录，将该记录所在事务加入ATT，状态为U（Undo
candidate，待Undo）。</li>
<li>如果遇到update记录，且涉及到的页不在DPT中，还要将涉及到的页加入DPT，并将recLSN设为该记录的LSN。</li>
</ol>
<p>完成Analysis过程后，DBMS拿到了crash发生时的事务状态和脏页情况。</p>
<h5 id="redo">Redo</h5>
<p>Redo的目的是恢复出crash时刻所有脏页上的修改情况。</p>
<p>从DPT中所有脏页recLSN的最小值对应的记录开始，重新执行所有update记录（包括CLR）并更新相应页面上的pageLSN，除非：</p>
<ol type="1">
<li>该操作影响的页不在DPT中。或者，</li>
<li>该操作影响的页在DPT中，但该页的recLSN大于该操作的LSN。（说明脏页上的修改不包括该操作）或者，</li>
<li>该操作影响的页在磁盘上的pageLSN大于该操作的LSN。（说明该操作的修改已经被持久化到磁盘上了）</li>
</ol>
<h5 id="undo">Undo</h5>
<p>针对所有状态为U的事务，按照LSN从大到小的顺序回退它们所做的操作，并记录CLR。</p>
<ol type="1">
<li>TO-UNDO集合初始包括所有状态为U的事务的lastLSN。</li>
<li>每轮循环中，选择并移除TO-UNDO集合中最大的LSN。如果是CLR记录，将其undoNextLSN（如果非空）加入集合；如果是update记录，将其previous
LSN（如果非空）加入集合，并写入对应的CLR记录。</li>
<li>循环步骤2，直到TO-UNDO集合为空为止。</li>
</ol>
<p>Undo可以进行lazy优化：不是立刻进行每条记录的回退操作，而是将需要回退的页记下来，后续其他事务访问这些页的时候才根据日志逐步回退。这样做的好处是数据库从crash恢复后可以很快接收并处理新事务，而不需要等待所有Undo完成。</p>
<p>三个阶段的操作涉及到的日志范围如图： <img
src="/images/15445/2.png" /></p>
<hr />
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57579023">Transaction
management：可串行性（serializability）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59535337">Transaction
management：两阶段锁（two-phase locking）</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.cl.cam.ac.uk/teaching/2000/ConcSys/csig2/57.html">Chapter
19 Concurrency Control</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1470863887393988608">刘学一的知乎专栏15-445/721
&amp; DBMS</a></li>
<li><a
target="_blank" rel="noopener" href="https://my.oschina.net/fileoptions/blog/2988622">图解数据库Aries事务Recovery算法</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2022/04/11/CMU-15-445-Notes-3/">https://stopire.github.io/2022/04/11/CMU-15-445-Notes-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/database/">database</a><a class="post-meta__tags" href="/tags/course/">course</a><a class="post-meta__tags" href="/tags/15-445/">15-445</a></div><div class="post_share"><div class="social-share" data-image="/images/post-cover/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/16/Arch-Gnome%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"><img class="prev-cover" src="/images/post-cover/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Arch+Gnome安装记录</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/05/15-445-Lab-Report/"><img class="next-cover" src="/images/post-cover/cover5.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">15-445 Lab Report</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/05/15-445-Lab-Report/" title="15-445 Lab Report"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">15-445 Lab Report</div></div></a></div><div><a href="/2022/01/23/CMU-15-445-Notes-2/" title="CMU 15-445 Notes(2)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">CMU 15-445 Notes(2)</div></div></a></div><div><a href="/2021/12/15/CMU-15-445-Notes/" title="CMU 15-445 Notes(1)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">CMU 15-445 Notes(1)</div></div></a></div><div><a href="/2022/01/25/Stanford-CS144-Notes-1/" title="Stanford CS144 Notes(1)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">Stanford CS144 Notes(1)</div></div></a></div><div><a href="/2022/03/01/Stanford-CS144-Notes-2/" title="Stanford CS144 Notes(2)"><img class="cover" src="/images/post-cover/cover4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">Stanford CS144 Notes(2)</div></div></a></div><div><a href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report"><img class="cover" src="/images/post-cover/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-16</div><div class="title">CS144 Lab Report</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-15-concurrency-control-theory"><span class="toc-number">1.</span> <span class="toc-text">Lecture 15 Concurrency
Control Theory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#atomicity"><span class="toc-number">1.1.</span> <span class="toc-text">Atomicity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#consistency"><span class="toc-number">1.2.</span> <span class="toc-text">Consistency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isolation"><span class="toc-number">1.3.</span> <span class="toc-text">Isolation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">等价性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#durability"><span class="toc-number">1.4.</span> <span class="toc-text">Durability</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-16-two-phase-locking"><span class="toc-number">2.</span> <span class="toc-text">Lecture 16 Two-Phase Locking</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pl"><span class="toc-number">2.1.</span> <span class="toc-text">2PL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rigorous-2pl"><span class="toc-number">2.2.</span> <span class="toc-text">Rigorous 2PL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deadlock"><span class="toc-number">2.3.</span> <span class="toc-text">Deadlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-granularity"><span class="toc-number">2.4.</span> <span class="toc-text">Lock Granularity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-17-timestamp-ordering"><span class="toc-number">3.</span> <span class="toc-text">Lecture 17 Timestamp
Ordering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#basic-timestamp-orderingbasic-to"><span class="toc-number">3.1.</span> <span class="toc-text">Basic Timestamp
Ordering（BASIC T&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#optimistic-concurrency-control-occ"><span class="toc-number">3.2.</span> <span class="toc-text">Optimistic Concurrency
Control （OCC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-18-multi-version-concurrency-control"><span class="toc-number">4.</span> <span class="toc-text">Lecture 18
Multi-Version Concurrency Control</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#version-storage"><span class="toc-number">4.1.</span> <span class="toc-text">Version Storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#garbage-collection"><span class="toc-number">4.2.</span> <span class="toc-text">Garbage Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index-management"><span class="toc-number">4.3.</span> <span class="toc-text">Index Management</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-19-logging-schemes"><span class="toc-number">5.</span> <span class="toc-text">Lecture 19 Logging Schemes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer-pool-policies"><span class="toc-number">5.1.</span> <span class="toc-text">Buffer Pool Policies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shadow-paging"><span class="toc-number">5.2.</span> <span class="toc-text">Shadow paging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-ahead-logging"><span class="toc-number">5.3.</span> <span class="toc-text">Write-Ahead Logging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#logging-scheme"><span class="toc-number">5.4.</span> <span class="toc-text">Logging Scheme</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkpoint"><span class="toc-number">5.5.</span> <span class="toc-text">Checkpoint</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lecture-20-aries-database-recovery"><span class="toc-number">6.</span> <span class="toc-text">Lecture 20 ARIES Database
Recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#normal-execution"><span class="toc-number">6.1.</span> <span class="toc-text">Normal Execution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkpoint-1"><span class="toc-number">6.2.</span> <span class="toc-text">Checkpoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recovery"><span class="toc-number">6.3.</span> <span class="toc-text">Recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#analysis"><span class="toc-number">6.3.1.</span> <span class="toc-text">Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo"><span class="toc-number">6.3.2.</span> <span class="toc-text">Redo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo"><span class="toc-number">6.3.3.</span> <span class="toc-text">Undo</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report"><img src="/images/post-cover/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS144 Lab Report"/></a><div class="content"><a class="title" href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report">CS144 Lab Report</a><time datetime="2022-11-16T07:25:07.000Z" title="发表于 2022-11-16 15:25:07">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/08/EXT4-extent/" title="EXT4-extent"><img src="/images/post-cover/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EXT4-extent"/></a><div class="content"><a class="title" href="/2022/10/08/EXT4-extent/" title="EXT4-extent">EXT4-extent</a><time datetime="2022-10-08T11:01:27.000Z" title="发表于 2022-10-08 19:01:27">2022-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Optimistic-crash-consistency/" title="Optimistic crash consistency"><img src="/images/post-cover/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Optimistic crash consistency"/></a><div class="content"><a class="title" href="/2022/09/25/Optimistic-crash-consistency/" title="Optimistic crash consistency">Optimistic crash consistency</a><time datetime="2022-09-25T11:32:55.000Z" title="发表于 2022-09-25 19:32:55">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/SplitFS-reducing-software-overhead-in-file-systems-for-persistent-memory/" title="SplitFS: reducing software overhead in file systems for persistent memory"><img src="/images/post-cover/cover5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SplitFS: reducing software overhead in file systems for persistent memory"/></a><div class="content"><a class="title" href="/2022/07/28/SplitFS-reducing-software-overhead-in-file-systems-for-persistent-memory/" title="SplitFS: reducing software overhead in file systems for persistent memory">SplitFS: reducing software overhead in file systems for persistent memory</a><time datetime="2022-07-28T12:15:34.000Z" title="发表于 2022-07-28 20:15:34">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/23/ctFS-Replacing-File-Indexing-with-Hardware-Memory-Translation-through-Contiguous-File-Allocation-for-Persistent-Memory/" title="ctFS: Replacing File Indexing with Hardware Memory Translation through Contiguous File Allocation for Persistent Memory"><img src="/images/post-cover/cover3.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ctFS: Replacing File Indexing with Hardware Memory Translation through Contiguous File Allocation for Persistent Memory"/></a><div class="content"><a class="title" href="/2022/07/23/ctFS-Replacing-File-Indexing-with-Hardware-Memory-Translation-through-Contiguous-File-Allocation-for-Persistent-Memory/" title="ctFS: Replacing File Indexing with Hardware Memory Translation through Contiguous File Allocation for Persistent Memory">ctFS: Replacing File Indexing with Hardware Memory Translation through Contiguous File Allocation for Persistent Memory</a><time datetime="2022-07-23T10:16:16.000Z" title="发表于 2022-07-23 18:16:16">2022-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>