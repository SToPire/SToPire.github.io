<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>15-445 Lab Report | Do not touch fish!</title><meta name="author" content="SToPire"><meta name="copyright" content="SToPire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CMU Intro to Database Systems (15-445) 2021 lab report.  CHEATING(X) gradescope上的测试用例是可以偷出来的，例如： 123456std::ifstream file(&amp;quot;&amp;#x2F;autograder&amp;#x2F;bustub&amp;#x2F;tes"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://stopire.github.io/2022/04/05/15-445-Lab-Report/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '15-445 Lab Report',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-14 22:15:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/post-cover/cover5.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Do not touch fish!</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">15-445 Lab Report</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T15:19:50.000Z" title="发表于 2022-04-05 23:19:50">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-14T14:15:24.411Z" title="更新于 2022-10-14 22:15:24">2022-10-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="15-445 Lab Report"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>CMU Intro to Database Systems (<a
target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/">15-445</a>) 2021 lab
report.</p>
<span id="more"></span>
<h3 id="cheatingx">CHEATING(X)</h3>
<p>gradescope上的测试用例是可以偷出来的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream <span class="title function_">file</span><span class="params">(<span class="string">&quot;/autograder/bustub/test/concurrency/grading_transaction_test.cpp&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (file.good()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::getline(file, str);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="project-1">Project 1</h3>
<p>第一个实验实现Buffer Pool Manager。</p>
<h4 id="lru-replacement-policy">LRU Replacement Policy</h4>
<p>该部分实现了一个基于LRU策略的Replacer，后面用它做Buffer Pool
Manager的页框替换。</p>
<p>Replacer的API都是针对页框（frame）而言的，它的接口有：</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bool Victim(frame_id_t *frame_id)</code></td>
<td>选出LRU的frame，返回其frame_id</td>
</tr>
<tr class="even">
<td><code>void Pin(frame_id_t frame_id)</code></td>
<td>Pin住一个frame，这个页框不能被Replacer选中以至于被移除</td>
</tr>
<tr class="odd">
<td><code>void Unpin(frame_id_t frame_id)</code></td>
<td>Unpin一个frame，这个页框可能被Replacer选中，从而被移除</td>
</tr>
</tbody>
</table>
<p>Replacer可以实现成一个链表，并使用<code>map&lt;frame_id, list::iterator&gt;</code>在链表中定位某元素，避免从头遍历：</p>
<ul>
<li><code>Unpin</code>把<code>frame_id</code>添加到链表头</li>
<li><code>Pin</code>把<code>frame_id</code>（如果存在于链表中）从链表中移除</li>
<li><code>Victim</code>从链表尾移除第一个元素，并存入<code>frame_id</code></li>
</ul>
<p>调用者需要注意<code>Pin</code>是幂等的，但<code>Unpin</code>不是（<code>frame_id</code>不能重复存在于链表中）。</p>
<h4 id="buffer-pool-manager-instance">Buffer Pool Manager Instance</h4>
<p>该部分实现了一个Buffer Pool
Manager（BPM）的实例。BPM拥有一些页框（frame），每个页框存放某一磁盘页（page）在内存中的缓存。一旦BPM已满，而又要读写新的Page，BPM就需要根据Replacer指出的Victim选择一个frame，将其中的page写回到磁盘，再将新page读入到该frame中。</p>
<p>数据结构<code>Page</code>包括实际页面内容和一些metadata：</p>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char data_[PAGE_SIZE]</code></td>
<td>存放实际的页面内容</td>
</tr>
<tr class="even">
<td><code>page_id_t page_id_</code></td>
<td>该页编号</td>
</tr>
<tr class="odd">
<td><code>int pin_count_</code></td>
<td>引用计数，即该页当前使用者的数目</td>
</tr>
<tr class="even">
<td><code>bool is_dirty_</code></td>
<td>该页内存中的副本是否与磁盘一致</td>
</tr>
</tbody>
</table>
<p>BPM的主要数据结构有：</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>Definition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Page *pages_</code></td>
<td>长度为<code>pool_size_</code>的数组，下标为<code>frame_id</code>。Page在内存中的缓存就被存放在这个数组中。</td>
</tr>
<tr class="even">
<td><code>unordered_map&lt;page_id_t, frame_id_t&gt; page_table_</code></td>
<td>从<code>page_id</code>到<code>frame_id</code>的反向映射</td>
</tr>
<tr class="odd">
<td><code>list&lt;frame_id_t&gt; free_list_</code></td>
<td>空闲链表，维护BPM中还有哪些frame空闲，可用来存放page。</td>
</tr>
</tbody>
</table>
<p>BPM提供的API有：</p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Page *FetchPage(page_id_t page_id)</td>
<td>获取编号为<code>page_id</code>的page，BPM需要保证该page在内存中</td>
</tr>
<tr class="even">
<td>bool UnpinPage(page_id_t page_id, bool is_dirty)</td>
<td>表明不再需要使用编号为<code>page_id</code>的page，BPM可以将该page换出内存</td>
</tr>
<tr class="odd">
<td>bool FlushPage(page_id_t page_id)</td>
<td>将编号为<code>page_id</code>的page写入磁盘，保证内存和磁盘的一致性</td>
</tr>
<tr class="even">
<td>Page <em>NewPage(page_id_t </em>page_id)</td>
<td>从磁盘上新分配一页，并装入BPM以供访问</td>
</tr>
<tr class="odd">
<td>bool DeletePage(page_id_t page_id)</td>
<td>删除一页，将该页内容从磁盘和内存中删除</td>
</tr>
<tr class="even">
<td>void FlushAllPagesImp()</td>
<td>对BPM中所有page做Flush操作</td>
</tr>
</tbody>
</table>
<h5 id="fetchpage">FetchPage()</h5>
<ol type="1">
<li>如果该页已经在BPM中，将其<code>pinCount</code>递增后直接返回。</li>
<li>如果该页不在BPM中，先检查<code>free_list</code>中是否有空闲的页框号；如果没有，需要调用<code>replacer-&gt;Victim()</code>确定一个LRU页框号，并将其中的page换出内存；如果所有页都被pin住，<code>FetchPage()</code>请求无法满足，返回空指针。</li>
<li>将page的metadata和实际内容装入页框中，并置其<code>pinCount</code>为1。</li>
</ol>
<h5 id="unpinpage">UnpinPage()</h5>
<ol type="1">
<li>如果该页不在BPM中，或是在BPM中但<code>pinCount &lt;= 0</code>，返回false。</li>
<li>递减该页的<code>pinCount</code>，如果递减之后<code>pinCount == 0</code>，调用<code>replacer-&gt;Unpin()</code>表明该页已经可以被换出内存。</li>
<li>如果参数<code>is_dirty == true</code>，将该页标记为脏页。</li>
</ol>
<h5 id="flushpage">FlushPage()</h5>
<ol type="1">
<li>如果该页不在BPM中，返回false。</li>
<li>如果该页为脏页，将其在内存中的内容写入磁盘。</li>
</ol>
<h5 id="newpage">NewPage()</h5>
<ol type="1">
<li>检查BPM中所有page的<code>pinCount</code>，如果所有页都被pin住，<code>NewPage()</code>请求无法满足，返回空指针。</li>
<li>类似<code>FetchPage()</code>，依次通过<code>free_list_</code>和<code>replacer-&gt;Victim()</code>找到一个空闲页框号，如果使用<code>replacer-&gt;Victim()</code>还要将原先这个页框中的页换出内存。</li>
<li>从磁盘上分配一页，得到<code>page_id</code>。将<code>page_id</code>和其他page
metadata写入页框，并置<code>pinCount</code>为1。</li>
</ol>
<h5 id="deletepage">DeletePage()</h5>
<ol type="1">
<li>如果该页不存在于BPM中，不需要删除，直接返回true。</li>
<li>如果该页存在于BPM中且<code>pinCount</code>不为0，说明有其他使用者使用该页，不能删除，返回false。</li>
<li>如果该页存在于BPM中且<code>pinCount == 0</code>，将其metadata和实际内容从BPM中抹去，并将该页归还给磁盘（Bustub实验中为空实现），供下次<code>NewPage()</code>从磁盘分配时使用。</li>
</ol>
<h4 id="parallel-buffer-pool-manager">Parallel Buffer Pool Manager</h4>
<p>所谓<code>ParallelBufferPoolManager</code>由<code>num_instances_</code>个<code>BufferPoolManagerInstance</code>组成。在每个<code>BufferPoolManagerInstance</code>由锁保护的同时，<code>ParallelBufferPoolManager</code>使得应用进程可以同时使用多个<code>BufferPoolManagerInstance</code>访问磁盘上的page，提高并行度。</p>
<p>在实现<code>ParallelBufferPoolManager</code>的API时，只要根据<code>page_id % num_instances_</code>决定对编号为<code>page_id</code>的页的访问应该由哪个<code>BufferPoolManagerInstance</code>执行即可，只有<code>NewPage()</code>例外：每个<code>BufferPoolManagerInstance</code>在向磁盘请求页的时候只能拿到其编号对应的<code>page_id</code>（例如<code>num_instances_ == 3</code>，则编号为0的<code>BufferPoolManagerInstance</code>的只能拿到编号为0，3，6...的page；编号为1的<code>BufferPoolManagerInstance</code>的只能拿到编号为1，4，7...的page，以此类推。），我们需要以round
robin的方式让每个<code>ParallelBufferPoolManager::NewPage()</code>请求落到不同的<code>BufferPoolManagerInstance</code>上（否则相当于只有一个<code>BufferPoolManagerInstance</code>，并行就没有意义了）。</p>
<hr />
<h3 id="project-2">Project 2</h3>
<p>2021Fall的课程中，第二个实验实现基于Hash的索引，具体来说是extendible
hashing算法，可参见<a
target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r4GkXtH1la8">这里</a>。</p>
<h4 id="page-layout">Page Layout</h4>
<p>作为数据库的一部分，Hash Index必须基于Buffer Pool
Manager，以Page为单位来访问内存。Bustub提供了两种<code>Page</code>类：</p>
<h5 id="hashtabledirectorypage">HashTableDirectoryPage</h5>
<p>Extendible Hash Table的目录页。</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 13%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Variable Name</strong></th>
<th><strong>Size</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>page_id_</code></td>
<td>4 bytes</td>
<td>Self Page Id</td>
</tr>
<tr class="even">
<td><code>lsn_</code></td>
<td>4 bytes</td>
<td>Log sequence number (Used in Project 4)</td>
</tr>
<tr class="odd">
<td><code>global_depth_</code></td>
<td>4 bytes</td>
<td>Global depth of the directory</td>
</tr>
<tr class="even">
<td><code>local_depths_</code></td>
<td>512 bytes</td>
<td>Array of local depths for each bucket (uint8)</td>
</tr>
<tr class="odd">
<td><code>bucket_page_ids_</code></td>
<td>2048 bytes</td>
<td>Array of bucket <code>page_id_t</code></td>
</tr>
</tbody>
</table>
<p>相关方法的实现都很trivial，值得一提的只有<code>GetSplitImageIndex()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalHighBit</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetLocalDepth</span>(bucket_idx) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (<span class="built_in">GetLocalDepth</span>(bucket_idx) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bucket_idx ^ <span class="built_in">GetLocalHighBit</span>(bucket_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，对<span class="math inline">\(localDepth=3\)</span>，<span
class="math inline">\(id=7\)</span>的bucket，其buddy bucket的id是<span
class="math inline">\(7 \oplus 100b = 111b \oplus 100b = 011b =
3\)</span>。</p>
<h5 id="hashtablebucketpage">HashTableBucketPage</h5>
<p>Extendible Hash
Table中的每一个桶（bucket）对应一个HashTableBucketPage。</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Variable Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char occupied_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1]</code></td>
<td>bitmap，该bucket中第i个KV pair是否曾经有效（被占用过）</td>
</tr>
<tr class="even">
<td><code>char readable_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1]</code></td>
<td>bitmap，该bucket中第i个KV pair是否可读（有效）</td>
</tr>
<tr class="odd">
<td>MappingType array_[0]</td>
<td>实际存放KV pair</td>
</tr>
</tbody>
</table>
<p>Project
2实际上并没有使用到<code>occupied_</code>，只用到了<code>readable_</code>。</p>
<p>HashTableBucketPage中的方法实现也比较trivial，插入、删除等方法采用遍历方式即可。</p>
<h4 id="hash-table-implementation">Hash Table Implementation</h4>
<p>该部分就是实现extendible hashing算法，一些需注意的点：</p>
<ol type="1">
<li>BPM的<code>NewPage()</code>方法本身就会让新分配的page的<code>pinCount=1</code>，不需要再去<code>FetchPage()</code>一次了，否则<code>pinCount</code>会不对。</li>
<li>保证<code>FetchPage()</code>（<code>NewPage()</code>）和<code>UnpinPage()</code>一一匹配（准确来说<code>UnpinPage()</code>可以多，但不能少），不然会导致BPM的<code>pinCount</code>计数异常，无法把不再使用的页换出内存。如果出现这种情况，改小测试样例中BPM的大小可以跑出这个bug。</li>
<li><code>SplitInsert()</code>并不一定只做一轮，如果local depth +
1之后还是无法分离超出一页的元素，还需要继续递归<code>SplitInsert()</code>直到能分开为止。</li>
<li><code>Merge()</code>成功后记得把不再使用的页<code>DeletePage()</code>掉。</li>
</ol>
<hr />
<h3 id="project-3">Project 3</h3>
<p>第三个实验实现了bustub的query执行引擎，该引擎基于Iterator
Model，每个操作符有<code>Init()</code>和<code>Next()</code>函数，<code>Next()</code>的语义是向上层操作符返回一个tuple，或是返回false表示没有更多tuple。</p>
<p>实验涉及到的bustub部分类：</p>
<ol type="1">
<li><code>AbstractExecutor</code>及其子类，即操作符。它们被组织成一个树状结构，用户对根节点Executor调用<code>Next()</code>，每次得到一个tuple，直到返回false为止。</li>
<li><code>AbstractPlanNode</code>及其子类，它们是每个操作符的具体参数，比如<code>SeqScanPlanNode</code>会包含表ID。PlanNode同样被组织成树结构，每个Executor唯一对应一个PlanNode。</li>
<li><code>Catalog</code>，可以看作数据库全局的元信息，维护表名、表ID、索引等信息。</li>
<li><code>Schema</code>，可以看作表/元组的元信息，表明一个表/元组由哪些列组成。</li>
<li><code>Tuple</code>，元组。<code>Tuple</code>和<code>Schema</code>放在一起才是完整的表。</li>
<li><code>AbstractExpression</code>及其子类，表达式。表达式可以被求值，并根据具体类型获得<code>Value</code>。比如<code>ComparisonExpression</code>求值后返回<code>bool</code>值，<code>ColumnExpression</code>求值后返回参数元组指定列上的值。</li>
</ol>
<h4 id="seqscan">SeqScan</h4>
<p>顺序扫描操作符在<code>Init()</code>维护表的当前和结尾迭代器，每次调用<code>Next()</code>时返回当前元组并递增迭代器，直到遇到表的结尾返回false。</p>
<p>注意PlanNode中指出了输出元组的schema，可能和表的schema不同。需要针对输出schema的每一列，从原始元组中拿出对应的值，拼接出新元组返回。</p>
<h4 id="insertupdatedelete">Insert/Update/Delete</h4>
<p>这三个操作符修改表中元组，此外还要相应修改对应的索引，索引的schema和表的schema不一样，所以操作索引的时候要用<code>Tuple::KeyFromTuple</code>把表的schema转成索引schema。</p>
<h4 id="nestedloopjoin">NestedLoopJoin</h4>
<p>该操作符是一个双层循环，比对左右子操作符返回的每个元组是否满足join条件（通过<code>plan_-&gt;Predicate()-&gt;EvaluateJoin()</code>完成）。如果满足，需要返回一个拼接后的大元组：将左/右子操作符返回的元组传给输出schema列表达式进行求值，得到大元组某一列的值，再进行拼接。</p>
<h4 id="hashjoin">HashJoin</h4>
<p>HashJoin是一个pipeline
breaker操作符，即需要子操作符传递完所有元组后才能返回。因此不同于其他操作符，它会在<code>Init()</code>中调用子操作符的<code>Next()</code>。</p>
<p><code>Init()</code>阶段：对左子操作符返回的每个元组，根据需要join的列上的值计算hash
key，存入哈希表（<code>unordered_map&lt;HashJoinKey, vector&lt;Tuple&gt;&gt;</code>）。再遍历右子操作符返回的元组，按同样方法计算hash
key。如果hash
key存在于表中，将右元组和所有匹配的左元组拼接，得到的大元组存在一个数组里。</p>
<p><code>Next()</code>阶段：遍历上述数组并逐元素返回。</p>
<h4 id="aggregate">Aggregate</h4>
<p>聚合操作符也是pipeline breaker操作符，也是通过哈希表实现的。</p>
<p><code>Init()</code>阶段：对子操作符返回的每个元组，根据group
by子句指定的列集合上的值计算hash key（相同hash
key说明属于同一个group），投入哈希表并更新维护的各个聚合值。哈希表中元素数目等于不同hash
key的数目。</p>
<p><code>Next()</code>阶段：遍历上述哈希表，并逐个返回满足having子句条件的元素。</p>
<h4 id="limit">Limit</h4>
<p>维护一个计数器，达到计数值后直接返回false。</p>
<h4 id="distinct">Distinct</h4>
<p>使用哈希表（<code>unordered_set&lt;DistinctKey&gt;</code>）实现。对子操作符返回的每个元组，根据其所有列上的值计算hash
key。如果hash key存在于表中说明重复，不返回该元组。</p>
<hr />
<h3 id="project4">Project4</h3>
<p>第四个实验实现并发的query execution.</p>
<h4 id="task12">Task1&amp;2</h4>
<p>前两个task实现<code>LockManager</code>和基于wound-wait的死锁避免。这里基本上面向测试用例编程，而且有很多confusing的地方，比如<code>granted_</code>这个属性完全没有用到。</p>
<p>Lock的粒度是rid，每个rid拥有一个<code>LockRequestQueue</code>，所有拿锁/正在拿锁的事务都会进入该队列。如果发生了锁的争抢，按照wound-wait原则：</p>
<ol type="1">
<li>老事务抢新事务的锁：新事务被杀死，老事务不用等待，直接拿到锁。</li>
<li>新事务抢老事务的锁：新事务需要等待老事务放锁。</li>
</ol>
<p>等待是通过每个<code>LockRequestQueue</code>上的条件变量实现的，<code>Unlock</code>时会<code>notify_all()</code>让所有等待者一起来抢。<code>LockRequestQueue</code>并不保证获得锁的顺序。</p>
<blockquote>
<p>这里看似有一个小问题：考虑事务0先拿到了锁，事务1,2先后试图拿锁并等待。此时事务0放锁，拿到锁的可能是事务2而非事务1。</p>
<p>我认为这种情况是可以接受的，因为没有规定事务1一定要比事务2先拿到锁，只要保证事务拿锁情况（成功或者被杀死）符合事务拿锁的先后顺序即可。在这个例子里，没有事务会被杀死，因此事务1和事务2最终都是能拿到锁的，符合预期，至于谁先拿到锁并不重要。</p>
<p>如果事务0先拿锁，后续事务试图拿锁的顺序是2,1,3，则事务2会被杀死，事务1和事务3最终都能拿到锁，谁先谁后不重要。</p>
</blockquote>
<p>一些注意点：</p>
<ol type="1">
<li><p>为<code>LockRequestQueue</code>引入了<code>exclusive_</code>和<code>shared_cnt_</code>两个额外变量，分别记录该rid上拿X锁的事务id和拿S锁的事务数目，避免每次拿锁都要扫整个队列。</p></li>
<li><p>根据用例，一个老事务试图拿锁时，不仅需要杀死正在拿锁的新事务，还需要杀死比它新的，正在等锁的事务。因此试图拿锁的事务等待在条件变量上之前就要把自己的<code>LockRequest</code>写入队列，不能等拿到锁了再写。</p></li>
<li><p>在wound过程中，Kill一个其他事务的方式就是把其状态设为Aborted，同时“帮”受害者更新<code>exclusive_</code>和<code>shared_cnt_</code>。为了避免重复更新这两个变量，需要引入为<code>LockRequest</code>引入一个valid标志，<code>Unlock</code>根据该标志确定是否还要更新<code>exclusive_</code>和<code>shared_cnt_</code>。</p>
<blockquote>
<p><code>Unlock()</code>仅仅通过事务状态是否为Aborted判断是否需要更新<code>exclusive_</code>和<code>shared_cnt_</code>是不够的，因为<code>Transaction::Abort()</code>会将事务状态设为Aborted，此时事务并没有被其他事务wound，是需要更新上述两个变量的。</p>
</blockquote></li>
</ol>
<h4 id="task3">Task3</h4>
<p>修改几个直接操作table的executor，上锁以支持并发执行。对于<code>Insert</code>，<code>Update</code>和<code>Delete</code>，直接拿X锁不放即可（注意在已经拿S锁的时候要用<code>LockUpgrade</code>拿X锁），对于<code>SeqScan</code>需要拿S锁，且区分不同的隔离级别：</p>
<table>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>S锁情况</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Read Uncommitted</td>
<td>不拿S锁</td>
</tr>
<tr class="even">
<td>Read Committed</td>
<td>拿S锁，用完就放（即不遵守2PL）</td>
</tr>
<tr class="odd">
<td>Repeatable Read</td>
<td>拿S锁不放（事务提交或终止时才放锁）</td>
</tr>
</tbody>
</table>
<p>这里有个小问题：<code>Insert</code>之前还没有<code>rid</code>，因此拿不到锁，只能在插入操作<code>InsertTuple()</code>完成之后再拿。这样做理论上是有问题的，不过测试样例没测到这里。</p>
<p>对于Rollback
test，需要在对应的executor里加上index的WriteRecord，不过不知道测试样例有没有测这些。Table的WriteRecord已经在表的操作函数里加好了，不需要我们手动加。</p>
<hr />
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.epis2048.net/2021/15445-lab4/index.html">epis2048's
Blog</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/Zhang-Each/Awesome-CS-Course-Learning-Notes/tree/master/CMU-15445-DatabaseSystem/lab">Zhang-Each's
Blog</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://stopire.github.io">SToPire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://stopire.github.io/2022/04/05/15-445-Lab-Report/">https://stopire.github.io/2022/04/05/15-445-Lab-Report/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stopire.github.io" target="_blank">Do not touch fish!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/database/">database</a><a class="post-meta__tags" href="/tags/course/">course</a><a class="post-meta__tags" href="/tags/15-445/">15-445</a></div><div class="post_share"><div class="social-share" data-image="/images/post-cover/cover5.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/11/CMU-15-445-Notes-3/"><img class="prev-cover" src="/images/post-cover/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CMU 15-445 Notes(3)</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/06/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/"><img class="next-cover" src="/images/post-cover/cover5.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux内存管理-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/23/CMU-15-445-Notes-2/" title="CMU 15-445 Notes(2)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">CMU 15-445 Notes(2)</div></div></a></div><div><a href="/2022/04/11/CMU-15-445-Notes-3/" title="CMU 15-445 Notes(3)"><img class="cover" src="/images/post-cover/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-11</div><div class="title">CMU 15-445 Notes(3)</div></div></a></div><div><a href="/2021/12/15/CMU-15-445-Notes/" title="CMU 15-445 Notes(1)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">CMU 15-445 Notes(1)</div></div></a></div><div><a href="/2022/01/25/Stanford-CS144-Notes-1/" title="Stanford CS144 Notes(1)"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">Stanford CS144 Notes(1)</div></div></a></div><div><a href="/2022/03/01/Stanford-CS144-Notes-2/" title="Stanford CS144 Notes(2)"><img class="cover" src="/images/post-cover/cover4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">Stanford CS144 Notes(2)</div></div></a></div><div><a href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report"><img class="cover" src="/images/post-cover/cover5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-16</div><div class="title">CS144 Lab Report</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SToPire</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SToPire"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:stopire@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#cheatingx"><span class="toc-number">1.</span> <span class="toc-text">CHEATING(X)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-1"><span class="toc-number">2.</span> <span class="toc-text">Project 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lru-replacement-policy"><span class="toc-number">2.1.</span> <span class="toc-text">LRU Replacement Policy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer-pool-manager-instance"><span class="toc-number">2.2.</span> <span class="toc-text">Buffer Pool Manager Instance</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fetchpage"><span class="toc-number">2.2.1.</span> <span class="toc-text">FetchPage()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unpinpage"><span class="toc-number">2.2.2.</span> <span class="toc-text">UnpinPage()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flushpage"><span class="toc-number">2.2.3.</span> <span class="toc-text">FlushPage()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newpage"><span class="toc-number">2.2.4.</span> <span class="toc-text">NewPage()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deletepage"><span class="toc-number">2.2.5.</span> <span class="toc-text">DeletePage()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallel-buffer-pool-manager"><span class="toc-number">2.3.</span> <span class="toc-text">Parallel Buffer Pool Manager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2"><span class="toc-number">3.</span> <span class="toc-text">Project 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#page-layout"><span class="toc-number">3.1.</span> <span class="toc-text">Page Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hashtabledirectorypage"><span class="toc-number">3.1.1.</span> <span class="toc-text">HashTableDirectoryPage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hashtablebucketpage"><span class="toc-number">3.1.2.</span> <span class="toc-text">HashTableBucketPage</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-table-implementation"><span class="toc-number">3.2.</span> <span class="toc-text">Hash Table Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3"><span class="toc-number">4.</span> <span class="toc-text">Project 3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#seqscan"><span class="toc-number">4.1.</span> <span class="toc-text">SeqScan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insertupdatedelete"><span class="toc-number">4.2.</span> <span class="toc-text">Insert&#x2F;Update&#x2F;Delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nestedloopjoin"><span class="toc-number">4.3.</span> <span class="toc-text">NestedLoopJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashjoin"><span class="toc-number">4.4.</span> <span class="toc-text">HashJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aggregate"><span class="toc-number">4.5.</span> <span class="toc-text">Aggregate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-number">4.6.</span> <span class="toc-text">Limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#distinct"><span class="toc-number">4.7.</span> <span class="toc-text">Distinct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project4"><span class="toc-number">5.</span> <span class="toc-text">Project4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#task12"><span class="toc-number">5.1.</span> <span class="toc-text">Task1&amp;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task3"><span class="toc-number">5.2.</span> <span class="toc-text">Task3</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/02/MIT-6-S081-Lab-Report/" title="MIT 6.S081 Lab Report"><img src="/images/post-cover/cover5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT 6.S081 Lab Report"/></a><div class="content"><a class="title" href="/2022/12/02/MIT-6-S081-Lab-Report/" title="MIT 6.S081 Lab Report">MIT 6.S081 Lab Report</a><time datetime="2022-12-01T18:01:19.000Z" title="发表于 2022-12-02 02:01:19">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/CS149-Lab-Report/" title="CS149 Lab Report"><img src="/images/post-cover/cover4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS149 Lab Report"/></a><div class="content"><a class="title" href="/2022/11/21/CS149-Lab-Report/" title="CS149 Lab Report">CS149 Lab Report</a><time datetime="2022-11-20T17:08:17.000Z" title="发表于 2022-11-21 01:08:17">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report"><img src="/images/post-cover/cover5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS144 Lab Report"/></a><div class="content"><a class="title" href="/2022/11/16/CS144-Lab-Report/" title="CS144 Lab Report">CS144 Lab Report</a><time datetime="2022-11-16T07:25:07.000Z" title="发表于 2022-11-16 15:25:07">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/08/EXT4-extent/" title="EXT4-extent"><img src="/images/post-cover/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EXT4-extent"/></a><div class="content"><a class="title" href="/2022/10/08/EXT4-extent/" title="EXT4-extent">EXT4-extent</a><time datetime="2022-10-08T11:01:27.000Z" title="发表于 2022-10-08 19:01:27">2022-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Optimistic-crash-consistency/" title="Optimistic crash consistency"><img src="/images/post-cover/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Optimistic crash consistency"/></a><div class="content"><a class="title" href="/2022/09/25/Optimistic-crash-consistency/" title="Optimistic crash consistency">Optimistic crash consistency</a><time datetime="2022-09-25T11:32:55.000Z" title="发表于 2022-09-25 19:32:55">2022-09-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By SToPire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>